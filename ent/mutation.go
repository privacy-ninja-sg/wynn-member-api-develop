// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"
	"wynn-member-api/ent/accesstoken"
	"wynn-member-api/ent/bank"
	"wynn-member-api/ent/bankaccount"
	"wynn-member-api/ent/channel"
	"wynn-member-api/ent/game"
	"wynn-member-api/ent/gameaccount"
	"wynn-member-api/ent/lineaccount"
	"wynn-member-api/ent/masterwallettransaction"
	"wynn-member-api/ent/pgslotaccount"
	"wynn-member-api/ent/predicate"
	"wynn-member-api/ent/prettygameaccount"
	"wynn-member-api/ent/sagameaccount"
	"wynn-member-api/ent/transfertransaction"
	"wynn-member-api/ent/user"

	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessToken             = "AccessToken"
	TypeBank                    = "Bank"
	TypeBankAccount             = "BankAccount"
	TypeChannel                 = "Channel"
	TypeGame                    = "Game"
	TypeGameAccount             = "GameAccount"
	TypeLineAccount             = "LineAccount"
	TypeMasterWalletTransaction = "MasterWalletTransaction"
	TypePgSlotAccount           = "PgSlotAccount"
	TypePrettyGameAccount       = "PrettyGameAccount"
	TypeSAGameAccount           = "SAGameAccount"
	TypeTransferTransaction     = "TransferTransaction"
	TypeUser                    = "User"
)

// AccessTokenMutation represents an operation that mutates the AccessToken nodes in the graph.
type AccessTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	line_token    *string
	access_token  *string
	token_expire  *time.Time
	ip            *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*AccessToken, error)
	predicates    []predicate.AccessToken
}

var _ ent.Mutation = (*AccessTokenMutation)(nil)

// accesstokenOption allows management of the mutation configuration using functional options.
type accesstokenOption func(*AccessTokenMutation)

// newAccessTokenMutation creates new mutation for the AccessToken entity.
func newAccessTokenMutation(c config, op Op, opts ...accesstokenOption) *AccessTokenMutation {
	m := &AccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessTokenID sets the ID field of the mutation.
func withAccessTokenID(id int) accesstokenOption {
	return func(m *AccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessToken
		)
		m.oldValue = func(ctx context.Context) (*AccessToken, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessToken sets the old AccessToken of the mutation.
func withAccessToken(node *AccessToken) accesstokenOption {
	return func(m *AccessTokenMutation) {
		m.oldValue = func(context.Context) (*AccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLineToken sets the "line_token" field.
func (m *AccessTokenMutation) SetLineToken(s string) {
	m.line_token = &s
}

// LineToken returns the value of the "line_token" field in the mutation.
func (m *AccessTokenMutation) LineToken() (r string, exists bool) {
	v := m.line_token
	if v == nil {
		return
	}
	return *v, true
}

// OldLineToken returns the old "line_token" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldLineToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLineToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLineToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineToken: %w", err)
	}
	return oldValue.LineToken, nil
}

// ClearLineToken clears the value of the "line_token" field.
func (m *AccessTokenMutation) ClearLineToken() {
	m.line_token = nil
	m.clearedFields[accesstoken.FieldLineToken] = struct{}{}
}

// LineTokenCleared returns if the "line_token" field was cleared in this mutation.
func (m *AccessTokenMutation) LineTokenCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldLineToken]
	return ok
}

// ResetLineToken resets all changes to the "line_token" field.
func (m *AccessTokenMutation) ResetLineToken() {
	m.line_token = nil
	delete(m.clearedFields, accesstoken.FieldLineToken)
}

// SetAccessToken sets the "access_token" field.
func (m *AccessTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *AccessTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *AccessTokenMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetTokenExpire sets the "token_expire" field.
func (m *AccessTokenMutation) SetTokenExpire(t time.Time) {
	m.token_expire = &t
}

// TokenExpire returns the value of the "token_expire" field in the mutation.
func (m *AccessTokenMutation) TokenExpire() (r time.Time, exists bool) {
	v := m.token_expire
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpire returns the old "token_expire" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldTokenExpire(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTokenExpire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTokenExpire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpire: %w", err)
	}
	return oldValue.TokenExpire, nil
}

// ResetTokenExpire resets all changes to the "token_expire" field.
func (m *AccessTokenMutation) ResetTokenExpire() {
	m.token_expire = nil
}

// SetIP sets the "ip" field.
func (m *AccessTokenMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AccessTokenMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *AccessTokenMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[accesstoken.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *AccessTokenMutation) IPCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *AccessTokenMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, accesstoken.FieldIP)
}

// SetCreatedAt sets the "created_at" field.
func (m *AccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccessTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccessTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccessTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AccessTokenMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AccessTokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AccessTokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AccessTokenMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AccessTokenMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AccessTokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AccessTokenMutation builder.
func (m *AccessTokenMutation) Where(ps ...predicate.AccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccessTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccessToken).
func (m *AccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.line_token != nil {
		fields = append(fields, accesstoken.FieldLineToken)
	}
	if m.access_token != nil {
		fields = append(fields, accesstoken.FieldAccessToken)
	}
	if m.token_expire != nil {
		fields = append(fields, accesstoken.FieldTokenExpire)
	}
	if m.ip != nil {
		fields = append(fields, accesstoken.FieldIP)
	}
	if m.created_at != nil {
		fields = append(fields, accesstoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accesstoken.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accesstoken.FieldLineToken:
		return m.LineToken()
	case accesstoken.FieldAccessToken:
		return m.AccessToken()
	case accesstoken.FieldTokenExpire:
		return m.TokenExpire()
	case accesstoken.FieldIP:
		return m.IP()
	case accesstoken.FieldCreatedAt:
		return m.CreatedAt()
	case accesstoken.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accesstoken.FieldLineToken:
		return m.OldLineToken(ctx)
	case accesstoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case accesstoken.FieldTokenExpire:
		return m.OldTokenExpire(ctx)
	case accesstoken.FieldIP:
		return m.OldIP(ctx)
	case accesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accesstoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accesstoken.FieldLineToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineToken(v)
		return nil
	case accesstoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case accesstoken.FieldTokenExpire:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpire(v)
		return nil
	case accesstoken.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case accesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accesstoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accesstoken.FieldLineToken) {
		fields = append(fields, accesstoken.FieldLineToken)
	}
	if m.FieldCleared(accesstoken.FieldIP) {
		fields = append(fields, accesstoken.FieldIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessTokenMutation) ClearField(name string) error {
	switch name {
	case accesstoken.FieldLineToken:
		m.ClearLineToken()
		return nil
	case accesstoken.FieldIP:
		m.ClearIP()
		return nil
	}
	return fmt.Errorf("unknown AccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessTokenMutation) ResetField(name string) error {
	switch name {
	case accesstoken.FieldLineToken:
		m.ResetLineToken()
		return nil
	case accesstoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case accesstoken.FieldTokenExpire:
		m.ResetTokenExpire()
		return nil
	case accesstoken.FieldIP:
		m.ResetIP()
		return nil
	case accesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accesstoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, accesstoken.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accesstoken.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, accesstoken.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case accesstoken.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessTokenMutation) ClearEdge(name string) error {
	switch name {
	case accesstoken.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown AccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessTokenMutation) ResetEdge(name string) error {
	switch name {
	case accesstoken.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown AccessToken edge %s", name)
}

// BankMutation represents an operation that mutates the Bank nodes in the graph.
type BankMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *uuid.UUID
	name              *string
	short_name        *string
	name_th           *string
	short_name_th     *string
	bank_account_name *string
	logo              *string
	bank_id           *string
	status            *bank.Status
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	accounts          map[int]struct{}
	removedaccounts   map[int]struct{}
	clearedaccounts   bool
	done              bool
	oldValue          func(context.Context) (*Bank, error)
	predicates        []predicate.Bank
}

var _ ent.Mutation = (*BankMutation)(nil)

// bankOption allows management of the mutation configuration using functional options.
type bankOption func(*BankMutation)

// newBankMutation creates new mutation for the Bank entity.
func newBankMutation(c config, op Op, opts ...bankOption) *BankMutation {
	m := &BankMutation{
		config:        c,
		op:            op,
		typ:           TypeBank,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBankID sets the ID field of the mutation.
func withBankID(id int) bankOption {
	return func(m *BankMutation) {
		var (
			err   error
			once  sync.Once
			value *Bank
		)
		m.oldValue = func(ctx context.Context) (*Bank, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bank.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBank sets the old Bank of the mutation.
func withBank(node *Bank) bankOption {
	return func(m *BankMutation) {
		m.oldValue = func(context.Context) (*Bank, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BankMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BankMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BankMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *BankMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *BankMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *BankMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *BankMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BankMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BankMutation) ResetName() {
	m.name = nil
}

// SetShortName sets the "short_name" field.
func (m *BankMutation) SetShortName(s string) {
	m.short_name = &s
}

// ShortName returns the value of the "short_name" field in the mutation.
func (m *BankMutation) ShortName() (r string, exists bool) {
	v := m.short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShortName returns the old "short_name" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortName: %w", err)
	}
	return oldValue.ShortName, nil
}

// ClearShortName clears the value of the "short_name" field.
func (m *BankMutation) ClearShortName() {
	m.short_name = nil
	m.clearedFields[bank.FieldShortName] = struct{}{}
}

// ShortNameCleared returns if the "short_name" field was cleared in this mutation.
func (m *BankMutation) ShortNameCleared() bool {
	_, ok := m.clearedFields[bank.FieldShortName]
	return ok
}

// ResetShortName resets all changes to the "short_name" field.
func (m *BankMutation) ResetShortName() {
	m.short_name = nil
	delete(m.clearedFields, bank.FieldShortName)
}

// SetNameTh sets the "name_th" field.
func (m *BankMutation) SetNameTh(s string) {
	m.name_th = &s
}

// NameTh returns the value of the "name_th" field in the mutation.
func (m *BankMutation) NameTh() (r string, exists bool) {
	v := m.name_th
	if v == nil {
		return
	}
	return *v, true
}

// OldNameTh returns the old "name_th" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldNameTh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNameTh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNameTh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameTh: %w", err)
	}
	return oldValue.NameTh, nil
}

// ClearNameTh clears the value of the "name_th" field.
func (m *BankMutation) ClearNameTh() {
	m.name_th = nil
	m.clearedFields[bank.FieldNameTh] = struct{}{}
}

// NameThCleared returns if the "name_th" field was cleared in this mutation.
func (m *BankMutation) NameThCleared() bool {
	_, ok := m.clearedFields[bank.FieldNameTh]
	return ok
}

// ResetNameTh resets all changes to the "name_th" field.
func (m *BankMutation) ResetNameTh() {
	m.name_th = nil
	delete(m.clearedFields, bank.FieldNameTh)
}

// SetShortNameTh sets the "short_name_th" field.
func (m *BankMutation) SetShortNameTh(s string) {
	m.short_name_th = &s
}

// ShortNameTh returns the value of the "short_name_th" field in the mutation.
func (m *BankMutation) ShortNameTh() (r string, exists bool) {
	v := m.short_name_th
	if v == nil {
		return
	}
	return *v, true
}

// OldShortNameTh returns the old "short_name_th" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldShortNameTh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShortNameTh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShortNameTh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortNameTh: %w", err)
	}
	return oldValue.ShortNameTh, nil
}

// ClearShortNameTh clears the value of the "short_name_th" field.
func (m *BankMutation) ClearShortNameTh() {
	m.short_name_th = nil
	m.clearedFields[bank.FieldShortNameTh] = struct{}{}
}

// ShortNameThCleared returns if the "short_name_th" field was cleared in this mutation.
func (m *BankMutation) ShortNameThCleared() bool {
	_, ok := m.clearedFields[bank.FieldShortNameTh]
	return ok
}

// ResetShortNameTh resets all changes to the "short_name_th" field.
func (m *BankMutation) ResetShortNameTh() {
	m.short_name_th = nil
	delete(m.clearedFields, bank.FieldShortNameTh)
}

// SetBankAccountName sets the "bank_account_name" field.
func (m *BankMutation) SetBankAccountName(s string) {
	m.bank_account_name = &s
}

// BankAccountName returns the value of the "bank_account_name" field in the mutation.
func (m *BankMutation) BankAccountName() (r string, exists bool) {
	v := m.bank_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountName returns the old "bank_account_name" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldBankAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountName: %w", err)
	}
	return oldValue.BankAccountName, nil
}

// ClearBankAccountName clears the value of the "bank_account_name" field.
func (m *BankMutation) ClearBankAccountName() {
	m.bank_account_name = nil
	m.clearedFields[bank.FieldBankAccountName] = struct{}{}
}

// BankAccountNameCleared returns if the "bank_account_name" field was cleared in this mutation.
func (m *BankMutation) BankAccountNameCleared() bool {
	_, ok := m.clearedFields[bank.FieldBankAccountName]
	return ok
}

// ResetBankAccountName resets all changes to the "bank_account_name" field.
func (m *BankMutation) ResetBankAccountName() {
	m.bank_account_name = nil
	delete(m.clearedFields, bank.FieldBankAccountName)
}

// SetLogo sets the "logo" field.
func (m *BankMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *BankMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *BankMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[bank.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *BankMutation) LogoCleared() bool {
	_, ok := m.clearedFields[bank.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *BankMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, bank.FieldLogo)
}

// SetBankID sets the "bank_id" field.
func (m *BankMutation) SetBankID(s string) {
	m.bank_id = &s
}

// BankID returns the value of the "bank_id" field in the mutation.
func (m *BankMutation) BankID() (r string, exists bool) {
	v := m.bank_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBankID returns the old "bank_id" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldBankID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankID: %w", err)
	}
	return oldValue.BankID, nil
}

// ClearBankID clears the value of the "bank_id" field.
func (m *BankMutation) ClearBankID() {
	m.bank_id = nil
	m.clearedFields[bank.FieldBankID] = struct{}{}
}

// BankIDCleared returns if the "bank_id" field was cleared in this mutation.
func (m *BankMutation) BankIDCleared() bool {
	_, ok := m.clearedFields[bank.FieldBankID]
	return ok
}

// ResetBankID resets all changes to the "bank_id" field.
func (m *BankMutation) ResetBankID() {
	m.bank_id = nil
	delete(m.clearedFields, bank.FieldBankID)
}

// SetStatus sets the "status" field.
func (m *BankMutation) SetStatus(b bank.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BankMutation) Status() (r bank.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldStatus(ctx context.Context) (v bank.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BankMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BankMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BankMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BankMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BankMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BankMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bank entity.
// If the Bank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BankMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAccountIDs adds the "accounts" edge to the BankAccount entity by ids.
func (m *BankMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the BankAccount entity.
func (m *BankMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the BankAccount entity was cleared.
func (m *BankMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the BankAccount entity by IDs.
func (m *BankMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the BankAccount entity.
func (m *BankMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *BankMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *BankMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the BankMutation builder.
func (m *BankMutation) Where(ps ...predicate.Bank) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BankMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bank).
func (m *BankMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BankMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, bank.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, bank.FieldName)
	}
	if m.short_name != nil {
		fields = append(fields, bank.FieldShortName)
	}
	if m.name_th != nil {
		fields = append(fields, bank.FieldNameTh)
	}
	if m.short_name_th != nil {
		fields = append(fields, bank.FieldShortNameTh)
	}
	if m.bank_account_name != nil {
		fields = append(fields, bank.FieldBankAccountName)
	}
	if m.logo != nil {
		fields = append(fields, bank.FieldLogo)
	}
	if m.bank_id != nil {
		fields = append(fields, bank.FieldBankID)
	}
	if m.status != nil {
		fields = append(fields, bank.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, bank.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bank.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BankMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bank.FieldUUID:
		return m.UUID()
	case bank.FieldName:
		return m.Name()
	case bank.FieldShortName:
		return m.ShortName()
	case bank.FieldNameTh:
		return m.NameTh()
	case bank.FieldShortNameTh:
		return m.ShortNameTh()
	case bank.FieldBankAccountName:
		return m.BankAccountName()
	case bank.FieldLogo:
		return m.Logo()
	case bank.FieldBankID:
		return m.BankID()
	case bank.FieldStatus:
		return m.Status()
	case bank.FieldCreatedAt:
		return m.CreatedAt()
	case bank.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BankMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bank.FieldUUID:
		return m.OldUUID(ctx)
	case bank.FieldName:
		return m.OldName(ctx)
	case bank.FieldShortName:
		return m.OldShortName(ctx)
	case bank.FieldNameTh:
		return m.OldNameTh(ctx)
	case bank.FieldShortNameTh:
		return m.OldShortNameTh(ctx)
	case bank.FieldBankAccountName:
		return m.OldBankAccountName(ctx)
	case bank.FieldLogo:
		return m.OldLogo(ctx)
	case bank.FieldBankID:
		return m.OldBankID(ctx)
	case bank.FieldStatus:
		return m.OldStatus(ctx)
	case bank.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bank.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bank field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bank.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case bank.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bank.FieldShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortName(v)
		return nil
	case bank.FieldNameTh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameTh(v)
		return nil
	case bank.FieldShortNameTh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortNameTh(v)
		return nil
	case bank.FieldBankAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountName(v)
		return nil
	case bank.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case bank.FieldBankID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankID(v)
		return nil
	case bank.FieldStatus:
		v, ok := value.(bank.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bank.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bank.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bank field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BankMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BankMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bank numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BankMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bank.FieldShortName) {
		fields = append(fields, bank.FieldShortName)
	}
	if m.FieldCleared(bank.FieldNameTh) {
		fields = append(fields, bank.FieldNameTh)
	}
	if m.FieldCleared(bank.FieldShortNameTh) {
		fields = append(fields, bank.FieldShortNameTh)
	}
	if m.FieldCleared(bank.FieldBankAccountName) {
		fields = append(fields, bank.FieldBankAccountName)
	}
	if m.FieldCleared(bank.FieldLogo) {
		fields = append(fields, bank.FieldLogo)
	}
	if m.FieldCleared(bank.FieldBankID) {
		fields = append(fields, bank.FieldBankID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BankMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BankMutation) ClearField(name string) error {
	switch name {
	case bank.FieldShortName:
		m.ClearShortName()
		return nil
	case bank.FieldNameTh:
		m.ClearNameTh()
		return nil
	case bank.FieldShortNameTh:
		m.ClearShortNameTh()
		return nil
	case bank.FieldBankAccountName:
		m.ClearBankAccountName()
		return nil
	case bank.FieldLogo:
		m.ClearLogo()
		return nil
	case bank.FieldBankID:
		m.ClearBankID()
		return nil
	}
	return fmt.Errorf("unknown Bank nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BankMutation) ResetField(name string) error {
	switch name {
	case bank.FieldUUID:
		m.ResetUUID()
		return nil
	case bank.FieldName:
		m.ResetName()
		return nil
	case bank.FieldShortName:
		m.ResetShortName()
		return nil
	case bank.FieldNameTh:
		m.ResetNameTh()
		return nil
	case bank.FieldShortNameTh:
		m.ResetShortNameTh()
		return nil
	case bank.FieldBankAccountName:
		m.ResetBankAccountName()
		return nil
	case bank.FieldLogo:
		m.ResetLogo()
		return nil
	case bank.FieldBankID:
		m.ResetBankID()
		return nil
	case bank.FieldStatus:
		m.ResetStatus()
		return nil
	case bank.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bank.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bank field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BankMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, bank.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BankMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bank.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BankMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedaccounts != nil {
		edges = append(edges, bank.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BankMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bank.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BankMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, bank.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BankMutation) EdgeCleared(name string) bool {
	switch name {
	case bank.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BankMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bank unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BankMutation) ResetEdge(name string) error {
	switch name {
	case bank.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown Bank edge %s", name)
}

// BankAccountMutation represents an operation that mutates the BankAccount nodes in the graph.
type BankAccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	uuid                 *uuid.UUID
	bank_account_id      *string
	bank_account_id_last *string
	bank_account_name    *string
	status               *bankaccount.Status
	bank_code            *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	owner                *int
	clearedowner         bool
	bank                 *int
	clearedbank          bool
	done                 bool
	oldValue             func(context.Context) (*BankAccount, error)
	predicates           []predicate.BankAccount
}

var _ ent.Mutation = (*BankAccountMutation)(nil)

// bankaccountOption allows management of the mutation configuration using functional options.
type bankaccountOption func(*BankAccountMutation)

// newBankAccountMutation creates new mutation for the BankAccount entity.
func newBankAccountMutation(c config, op Op, opts ...bankaccountOption) *BankAccountMutation {
	m := &BankAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeBankAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBankAccountID sets the ID field of the mutation.
func withBankAccountID(id int) bankaccountOption {
	return func(m *BankAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *BankAccount
		)
		m.oldValue = func(ctx context.Context) (*BankAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BankAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBankAccount sets the old BankAccount of the mutation.
func withBankAccount(node *BankAccount) bankaccountOption {
	return func(m *BankAccountMutation) {
		m.oldValue = func(context.Context) (*BankAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BankAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BankAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BankAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *BankAccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *BankAccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *BankAccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetBankAccountID sets the "bank_account_id" field.
func (m *BankAccountMutation) SetBankAccountID(s string) {
	m.bank_account_id = &s
}

// BankAccountID returns the value of the "bank_account_id" field in the mutation.
func (m *BankAccountMutation) BankAccountID() (r string, exists bool) {
	v := m.bank_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountID returns the old "bank_account_id" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldBankAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountID: %w", err)
	}
	return oldValue.BankAccountID, nil
}

// ResetBankAccountID resets all changes to the "bank_account_id" field.
func (m *BankAccountMutation) ResetBankAccountID() {
	m.bank_account_id = nil
}

// SetBankAccountIDLast sets the "bank_account_id_last" field.
func (m *BankAccountMutation) SetBankAccountIDLast(s string) {
	m.bank_account_id_last = &s
}

// BankAccountIDLast returns the value of the "bank_account_id_last" field in the mutation.
func (m *BankAccountMutation) BankAccountIDLast() (r string, exists bool) {
	v := m.bank_account_id_last
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountIDLast returns the old "bank_account_id_last" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldBankAccountIDLast(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankAccountIDLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankAccountIDLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountIDLast: %w", err)
	}
	return oldValue.BankAccountIDLast, nil
}

// ResetBankAccountIDLast resets all changes to the "bank_account_id_last" field.
func (m *BankAccountMutation) ResetBankAccountIDLast() {
	m.bank_account_id_last = nil
}

// SetBankAccountName sets the "bank_account_name" field.
func (m *BankAccountMutation) SetBankAccountName(s string) {
	m.bank_account_name = &s
}

// BankAccountName returns the value of the "bank_account_name" field in the mutation.
func (m *BankAccountMutation) BankAccountName() (r string, exists bool) {
	v := m.bank_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountName returns the old "bank_account_name" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldBankAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountName: %w", err)
	}
	return oldValue.BankAccountName, nil
}

// ResetBankAccountName resets all changes to the "bank_account_name" field.
func (m *BankAccountMutation) ResetBankAccountName() {
	m.bank_account_name = nil
}

// SetStatus sets the "status" field.
func (m *BankAccountMutation) SetStatus(b bankaccount.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BankAccountMutation) Status() (r bankaccount.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldStatus(ctx context.Context) (v bankaccount.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BankAccountMutation) ResetStatus() {
	m.status = nil
}

// SetBankCode sets the "bank_code" field.
func (m *BankAccountMutation) SetBankCode(s string) {
	m.bank_code = &s
}

// BankCode returns the value of the "bank_code" field in the mutation.
func (m *BankAccountMutation) BankCode() (r string, exists bool) {
	v := m.bank_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCode returns the old "bank_code" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldBankCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCode: %w", err)
	}
	return oldValue.BankCode, nil
}

// ClearBankCode clears the value of the "bank_code" field.
func (m *BankAccountMutation) ClearBankCode() {
	m.bank_code = nil
	m.clearedFields[bankaccount.FieldBankCode] = struct{}{}
}

// BankCodeCleared returns if the "bank_code" field was cleared in this mutation.
func (m *BankAccountMutation) BankCodeCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldBankCode]
	return ok
}

// ResetBankCode resets all changes to the "bank_code" field.
func (m *BankAccountMutation) ResetBankCode() {
	m.bank_code = nil
	delete(m.clearedFields, bankaccount.FieldBankCode)
}

// SetCreatedAt sets the "created_at" field.
func (m *BankAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BankAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BankAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BankAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BankAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BankAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *BankAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *BankAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *BankAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BankAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BankAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BankAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetBankID sets the "bank" edge to the Bank entity by id.
func (m *BankAccountMutation) SetBankID(id int) {
	m.bank = &id
}

// ClearBank clears the "bank" edge to the Bank entity.
func (m *BankAccountMutation) ClearBank() {
	m.clearedbank = true
}

// BankCleared reports if the "bank" edge to the Bank entity was cleared.
func (m *BankAccountMutation) BankCleared() bool {
	return m.clearedbank
}

// BankID returns the "bank" edge ID in the mutation.
func (m *BankAccountMutation) BankID() (id int, exists bool) {
	if m.bank != nil {
		return *m.bank, true
	}
	return
}

// BankIDs returns the "bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BankID instead. It exists only for internal usage by the builders.
func (m *BankAccountMutation) BankIDs() (ids []int) {
	if id := m.bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBank resets all changes to the "bank" edge.
func (m *BankAccountMutation) ResetBank() {
	m.bank = nil
	m.clearedbank = false
}

// Where appends a list predicates to the BankAccountMutation builder.
func (m *BankAccountMutation) Where(ps ...predicate.BankAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BankAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BankAccount).
func (m *BankAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BankAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, bankaccount.FieldUUID)
	}
	if m.bank_account_id != nil {
		fields = append(fields, bankaccount.FieldBankAccountID)
	}
	if m.bank_account_id_last != nil {
		fields = append(fields, bankaccount.FieldBankAccountIDLast)
	}
	if m.bank_account_name != nil {
		fields = append(fields, bankaccount.FieldBankAccountName)
	}
	if m.status != nil {
		fields = append(fields, bankaccount.FieldStatus)
	}
	if m.bank_code != nil {
		fields = append(fields, bankaccount.FieldBankCode)
	}
	if m.created_at != nil {
		fields = append(fields, bankaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bankaccount.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BankAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bankaccount.FieldUUID:
		return m.UUID()
	case bankaccount.FieldBankAccountID:
		return m.BankAccountID()
	case bankaccount.FieldBankAccountIDLast:
		return m.BankAccountIDLast()
	case bankaccount.FieldBankAccountName:
		return m.BankAccountName()
	case bankaccount.FieldStatus:
		return m.Status()
	case bankaccount.FieldBankCode:
		return m.BankCode()
	case bankaccount.FieldCreatedAt:
		return m.CreatedAt()
	case bankaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BankAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bankaccount.FieldUUID:
		return m.OldUUID(ctx)
	case bankaccount.FieldBankAccountID:
		return m.OldBankAccountID(ctx)
	case bankaccount.FieldBankAccountIDLast:
		return m.OldBankAccountIDLast(ctx)
	case bankaccount.FieldBankAccountName:
		return m.OldBankAccountName(ctx)
	case bankaccount.FieldStatus:
		return m.OldStatus(ctx)
	case bankaccount.FieldBankCode:
		return m.OldBankCode(ctx)
	case bankaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bankaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BankAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bankaccount.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case bankaccount.FieldBankAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountID(v)
		return nil
	case bankaccount.FieldBankAccountIDLast:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountIDLast(v)
		return nil
	case bankaccount.FieldBankAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountName(v)
		return nil
	case bankaccount.FieldStatus:
		v, ok := value.(bankaccount.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bankaccount.FieldBankCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCode(v)
		return nil
	case bankaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bankaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BankAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BankAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BankAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BankAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BankAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bankaccount.FieldBankCode) {
		fields = append(fields, bankaccount.FieldBankCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BankAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BankAccountMutation) ClearField(name string) error {
	switch name {
	case bankaccount.FieldBankCode:
		m.ClearBankCode()
		return nil
	}
	return fmt.Errorf("unknown BankAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BankAccountMutation) ResetField(name string) error {
	switch name {
	case bankaccount.FieldUUID:
		m.ResetUUID()
		return nil
	case bankaccount.FieldBankAccountID:
		m.ResetBankAccountID()
		return nil
	case bankaccount.FieldBankAccountIDLast:
		m.ResetBankAccountIDLast()
		return nil
	case bankaccount.FieldBankAccountName:
		m.ResetBankAccountName()
		return nil
	case bankaccount.FieldStatus:
		m.ResetStatus()
		return nil
	case bankaccount.FieldBankCode:
		m.ResetBankCode()
		return nil
	case bankaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bankaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BankAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BankAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, bankaccount.EdgeOwner)
	}
	if m.bank != nil {
		edges = append(edges, bankaccount.EdgeBank)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BankAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bankaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case bankaccount.EdgeBank:
		if id := m.bank; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BankAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BankAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BankAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, bankaccount.EdgeOwner)
	}
	if m.clearedbank {
		edges = append(edges, bankaccount.EdgeBank)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BankAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case bankaccount.EdgeOwner:
		return m.clearedowner
	case bankaccount.EdgeBank:
		return m.clearedbank
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BankAccountMutation) ClearEdge(name string) error {
	switch name {
	case bankaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	case bankaccount.EdgeBank:
		m.ClearBank()
		return nil
	}
	return fmt.Errorf("unknown BankAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BankAccountMutation) ResetEdge(name string) error {
	switch name {
	case bankaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	case bankaccount.EdgeBank:
		m.ResetBank()
		return nil
	}
	return fmt.Errorf("unknown BankAccount edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	name          *string
	status        *channel.Status
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Channel, error)
	predicates    []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ChannelMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ChannelMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ChannelMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(c channel.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r channel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v channel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *ChannelMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *ChannelMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *ChannelMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *ChannelMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, channel.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldUUID:
		return m.UUID()
	case channel.FieldName:
		return m.Name()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldUUID:
		return m.OldUUID(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(channel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldUUID:
		m.ResetUUID()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, channel.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser != nil {
		edges = append(edges, channel.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, channel.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// GameMutation represents an operation that mutates the Game nodes in the graph.
type GameMutation struct {
	config
	op               Op
	typ              string
	id               *int
	uuid             *uuid.UUID
	name             *string
	banner           *string
	desc             *string
	status           *game.Status
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	accounts         map[int]struct{}
	removedaccounts  map[int]struct{}
	clearedaccounts  bool
	transfers        map[int]struct{}
	removedtransfers map[int]struct{}
	clearedtransfers bool
	done             bool
	oldValue         func(context.Context) (*Game, error)
	predicates       []predicate.Game
}

var _ ent.Mutation = (*GameMutation)(nil)

// gameOption allows management of the mutation configuration using functional options.
type gameOption func(*GameMutation)

// newGameMutation creates new mutation for the Game entity.
func newGameMutation(c config, op Op, opts ...gameOption) *GameMutation {
	m := &GameMutation{
		config:        c,
		op:            op,
		typ:           TypeGame,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameID sets the ID field of the mutation.
func withGameID(id int) gameOption {
	return func(m *GameMutation) {
		var (
			err   error
			once  sync.Once
			value *Game
		)
		m.oldValue = func(ctx context.Context) (*Game, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Game.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGame sets the old Game of the mutation.
func withGame(node *Game) gameOption {
	return func(m *GameMutation) {
		m.oldValue = func(context.Context) (*Game, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *GameMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *GameMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *GameMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *GameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GameMutation) ResetName() {
	m.name = nil
}

// SetBanner sets the "banner" field.
func (m *GameMutation) SetBanner(s string) {
	m.banner = &s
}

// Banner returns the value of the "banner" field in the mutation.
func (m *GameMutation) Banner() (r string, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBanner returns the old "banner" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanner: %w", err)
	}
	return oldValue.Banner, nil
}

// ClearBanner clears the value of the "banner" field.
func (m *GameMutation) ClearBanner() {
	m.banner = nil
	m.clearedFields[game.FieldBanner] = struct{}{}
}

// BannerCleared returns if the "banner" field was cleared in this mutation.
func (m *GameMutation) BannerCleared() bool {
	_, ok := m.clearedFields[game.FieldBanner]
	return ok
}

// ResetBanner resets all changes to the "banner" field.
func (m *GameMutation) ResetBanner() {
	m.banner = nil
	delete(m.clearedFields, game.FieldBanner)
}

// SetDesc sets the "desc" field.
func (m *GameMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *GameMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *GameMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[game.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *GameMutation) DescCleared() bool {
	_, ok := m.clearedFields[game.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *GameMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, game.FieldDesc)
}

// SetStatus sets the "status" field.
func (m *GameMutation) SetStatus(ga game.Status) {
	m.status = &ga
}

// Status returns the value of the "status" field in the mutation.
func (m *GameMutation) Status() (r game.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldStatus(ctx context.Context) (v game.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GameMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GameMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GameMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GameMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GameMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAccountIDs adds the "accounts" edge to the GameAccount entity by ids.
func (m *GameMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the GameAccount entity.
func (m *GameMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the GameAccount entity was cleared.
func (m *GameMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the GameAccount entity by IDs.
func (m *GameMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the GameAccount entity.
func (m *GameMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *GameMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *GameMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTransferIDs adds the "transfers" edge to the TransferTransaction entity by ids.
func (m *GameMutation) AddTransferIDs(ids ...int) {
	if m.transfers == nil {
		m.transfers = make(map[int]struct{})
	}
	for i := range ids {
		m.transfers[ids[i]] = struct{}{}
	}
}

// ClearTransfers clears the "transfers" edge to the TransferTransaction entity.
func (m *GameMutation) ClearTransfers() {
	m.clearedtransfers = true
}

// TransfersCleared reports if the "transfers" edge to the TransferTransaction entity was cleared.
func (m *GameMutation) TransfersCleared() bool {
	return m.clearedtransfers
}

// RemoveTransferIDs removes the "transfers" edge to the TransferTransaction entity by IDs.
func (m *GameMutation) RemoveTransferIDs(ids ...int) {
	if m.removedtransfers == nil {
		m.removedtransfers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transfers, ids[i])
		m.removedtransfers[ids[i]] = struct{}{}
	}
}

// RemovedTransfers returns the removed IDs of the "transfers" edge to the TransferTransaction entity.
func (m *GameMutation) RemovedTransfersIDs() (ids []int) {
	for id := range m.removedtransfers {
		ids = append(ids, id)
	}
	return
}

// TransfersIDs returns the "transfers" edge IDs in the mutation.
func (m *GameMutation) TransfersIDs() (ids []int) {
	for id := range m.transfers {
		ids = append(ids, id)
	}
	return
}

// ResetTransfers resets all changes to the "transfers" edge.
func (m *GameMutation) ResetTransfers() {
	m.transfers = nil
	m.clearedtransfers = false
	m.removedtransfers = nil
}

// Where appends a list predicates to the GameMutation builder.
func (m *GameMutation) Where(ps ...predicate.Game) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Game).
func (m *GameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, game.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, game.FieldName)
	}
	if m.banner != nil {
		fields = append(fields, game.FieldBanner)
	}
	if m.desc != nil {
		fields = append(fields, game.FieldDesc)
	}
	if m.status != nil {
		fields = append(fields, game.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, game.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, game.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case game.FieldUUID:
		return m.UUID()
	case game.FieldName:
		return m.Name()
	case game.FieldBanner:
		return m.Banner()
	case game.FieldDesc:
		return m.Desc()
	case game.FieldStatus:
		return m.Status()
	case game.FieldCreatedAt:
		return m.CreatedAt()
	case game.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case game.FieldUUID:
		return m.OldUUID(ctx)
	case game.FieldName:
		return m.OldName(ctx)
	case game.FieldBanner:
		return m.OldBanner(ctx)
	case game.FieldDesc:
		return m.OldDesc(ctx)
	case game.FieldStatus:
		return m.OldStatus(ctx)
	case game.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case game.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Game field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case game.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case game.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case game.FieldBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanner(v)
		return nil
	case game.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case game.FieldStatus:
		v, ok := value.(game.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case game.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case game.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Game numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(game.FieldBanner) {
		fields = append(fields, game.FieldBanner)
	}
	if m.FieldCleared(game.FieldDesc) {
		fields = append(fields, game.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMutation) ClearField(name string) error {
	switch name {
	case game.FieldBanner:
		m.ClearBanner()
		return nil
	case game.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Game nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMutation) ResetField(name string) error {
	switch name {
	case game.FieldUUID:
		m.ResetUUID()
		return nil
	case game.FieldName:
		m.ResetName()
		return nil
	case game.FieldBanner:
		m.ResetBanner()
		return nil
	case game.FieldDesc:
		m.ResetDesc()
		return nil
	case game.FieldStatus:
		m.ResetStatus()
		return nil
	case game.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case game.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, game.EdgeAccounts)
	}
	if m.transfers != nil {
		edges = append(edges, game.EdgeTransfers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeTransfers:
		ids := make([]ent.Value, 0, len(m.transfers))
		for id := range m.transfers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, game.EdgeAccounts)
	}
	if m.removedtransfers != nil {
		edges = append(edges, game.EdgeTransfers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeTransfers:
		ids := make([]ent.Value, 0, len(m.removedtransfers))
		for id := range m.removedtransfers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, game.EdgeAccounts)
	}
	if m.clearedtransfers {
		edges = append(edges, game.EdgeTransfers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMutation) EdgeCleared(name string) bool {
	switch name {
	case game.EdgeAccounts:
		return m.clearedaccounts
	case game.EdgeTransfers:
		return m.clearedtransfers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Game unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMutation) ResetEdge(name string) error {
	switch name {
	case game.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case game.EdgeTransfers:
		m.ResetTransfers()
		return nil
	}
	return fmt.Errorf("unknown Game edge %s", name)
}

// GameAccountMutation represents an operation that mutates the GameAccount nodes in the graph.
type GameAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	game          *int
	clearedgame   bool
	pgslot        map[int]struct{}
	removedpgslot map[int]struct{}
	clearedpgslot bool
	pretty        map[int]struct{}
	removedpretty map[int]struct{}
	clearedpretty bool
	sagame        map[int]struct{}
	removedsagame map[int]struct{}
	clearedsagame bool
	done          bool
	oldValue      func(context.Context) (*GameAccount, error)
	predicates    []predicate.GameAccount
}

var _ ent.Mutation = (*GameAccountMutation)(nil)

// gameaccountOption allows management of the mutation configuration using functional options.
type gameaccountOption func(*GameAccountMutation)

// newGameAccountMutation creates new mutation for the GameAccount entity.
func newGameAccountMutation(c config, op Op, opts ...gameaccountOption) *GameAccountMutation {
	m := &GameAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeGameAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameAccountID sets the ID field of the mutation.
func withGameAccountID(id int) gameaccountOption {
	return func(m *GameAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *GameAccount
		)
		m.oldValue = func(ctx context.Context) (*GameAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameAccount sets the old GameAccount of the mutation.
func withGameAccount(node *GameAccount) gameaccountOption {
	return func(m *GameAccountMutation) {
		m.oldValue = func(context.Context) (*GameAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *GameAccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *GameAccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the GameAccount entity.
// If the GameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameAccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *GameAccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GameAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GameAccount entity.
// If the GameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GameAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GameAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GameAccount entity.
// If the GameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GameAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *GameAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *GameAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *GameAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *GameAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *GameAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *GameAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *GameAccountMutation) SetGameID(id int) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *GameAccountMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *GameAccountMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *GameAccountMutation) GameID() (id int, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *GameAccountMutation) GameIDs() (ids []int) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *GameAccountMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// AddPgslotIDs adds the "pgslot" edge to the PgSlotAccount entity by ids.
func (m *GameAccountMutation) AddPgslotIDs(ids ...int) {
	if m.pgslot == nil {
		m.pgslot = make(map[int]struct{})
	}
	for i := range ids {
		m.pgslot[ids[i]] = struct{}{}
	}
}

// ClearPgslot clears the "pgslot" edge to the PgSlotAccount entity.
func (m *GameAccountMutation) ClearPgslot() {
	m.clearedpgslot = true
}

// PgslotCleared reports if the "pgslot" edge to the PgSlotAccount entity was cleared.
func (m *GameAccountMutation) PgslotCleared() bool {
	return m.clearedpgslot
}

// RemovePgslotIDs removes the "pgslot" edge to the PgSlotAccount entity by IDs.
func (m *GameAccountMutation) RemovePgslotIDs(ids ...int) {
	if m.removedpgslot == nil {
		m.removedpgslot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pgslot, ids[i])
		m.removedpgslot[ids[i]] = struct{}{}
	}
}

// RemovedPgslot returns the removed IDs of the "pgslot" edge to the PgSlotAccount entity.
func (m *GameAccountMutation) RemovedPgslotIDs() (ids []int) {
	for id := range m.removedpgslot {
		ids = append(ids, id)
	}
	return
}

// PgslotIDs returns the "pgslot" edge IDs in the mutation.
func (m *GameAccountMutation) PgslotIDs() (ids []int) {
	for id := range m.pgslot {
		ids = append(ids, id)
	}
	return
}

// ResetPgslot resets all changes to the "pgslot" edge.
func (m *GameAccountMutation) ResetPgslot() {
	m.pgslot = nil
	m.clearedpgslot = false
	m.removedpgslot = nil
}

// AddPrettyIDs adds the "pretty" edge to the PrettyGameAccount entity by ids.
func (m *GameAccountMutation) AddPrettyIDs(ids ...int) {
	if m.pretty == nil {
		m.pretty = make(map[int]struct{})
	}
	for i := range ids {
		m.pretty[ids[i]] = struct{}{}
	}
}

// ClearPretty clears the "pretty" edge to the PrettyGameAccount entity.
func (m *GameAccountMutation) ClearPretty() {
	m.clearedpretty = true
}

// PrettyCleared reports if the "pretty" edge to the PrettyGameAccount entity was cleared.
func (m *GameAccountMutation) PrettyCleared() bool {
	return m.clearedpretty
}

// RemovePrettyIDs removes the "pretty" edge to the PrettyGameAccount entity by IDs.
func (m *GameAccountMutation) RemovePrettyIDs(ids ...int) {
	if m.removedpretty == nil {
		m.removedpretty = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pretty, ids[i])
		m.removedpretty[ids[i]] = struct{}{}
	}
}

// RemovedPretty returns the removed IDs of the "pretty" edge to the PrettyGameAccount entity.
func (m *GameAccountMutation) RemovedPrettyIDs() (ids []int) {
	for id := range m.removedpretty {
		ids = append(ids, id)
	}
	return
}

// PrettyIDs returns the "pretty" edge IDs in the mutation.
func (m *GameAccountMutation) PrettyIDs() (ids []int) {
	for id := range m.pretty {
		ids = append(ids, id)
	}
	return
}

// ResetPretty resets all changes to the "pretty" edge.
func (m *GameAccountMutation) ResetPretty() {
	m.pretty = nil
	m.clearedpretty = false
	m.removedpretty = nil
}

// AddSagameIDs adds the "sagame" edge to the SAGameAccount entity by ids.
func (m *GameAccountMutation) AddSagameIDs(ids ...int) {
	if m.sagame == nil {
		m.sagame = make(map[int]struct{})
	}
	for i := range ids {
		m.sagame[ids[i]] = struct{}{}
	}
}

// ClearSagame clears the "sagame" edge to the SAGameAccount entity.
func (m *GameAccountMutation) ClearSagame() {
	m.clearedsagame = true
}

// SagameCleared reports if the "sagame" edge to the SAGameAccount entity was cleared.
func (m *GameAccountMutation) SagameCleared() bool {
	return m.clearedsagame
}

// RemoveSagameIDs removes the "sagame" edge to the SAGameAccount entity by IDs.
func (m *GameAccountMutation) RemoveSagameIDs(ids ...int) {
	if m.removedsagame == nil {
		m.removedsagame = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sagame, ids[i])
		m.removedsagame[ids[i]] = struct{}{}
	}
}

// RemovedSagame returns the removed IDs of the "sagame" edge to the SAGameAccount entity.
func (m *GameAccountMutation) RemovedSagameIDs() (ids []int) {
	for id := range m.removedsagame {
		ids = append(ids, id)
	}
	return
}

// SagameIDs returns the "sagame" edge IDs in the mutation.
func (m *GameAccountMutation) SagameIDs() (ids []int) {
	for id := range m.sagame {
		ids = append(ids, id)
	}
	return
}

// ResetSagame resets all changes to the "sagame" edge.
func (m *GameAccountMutation) ResetSagame() {
	m.sagame = nil
	m.clearedsagame = false
	m.removedsagame = nil
}

// Where appends a list predicates to the GameAccountMutation builder.
func (m *GameAccountMutation) Where(ps ...predicate.GameAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GameAccount).
func (m *GameAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameAccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, gameaccount.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, gameaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gameaccount.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameaccount.FieldUUID:
		return m.UUID()
	case gameaccount.FieldCreatedAt:
		return m.CreatedAt()
	case gameaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameaccount.FieldUUID:
		return m.OldUUID(ctx)
	case gameaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gameaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GameAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameaccount.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case gameaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gameaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GameAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameAccountMutation) ResetField(name string) error {
	switch name {
	case gameaccount.FieldUUID:
		m.ResetUUID()
		return nil
	case gameaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gameaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GameAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, gameaccount.EdgeOwner)
	}
	if m.game != nil {
		edges = append(edges, gameaccount.EdgeGame)
	}
	if m.pgslot != nil {
		edges = append(edges, gameaccount.EdgePgslot)
	}
	if m.pretty != nil {
		edges = append(edges, gameaccount.EdgePretty)
	}
	if m.sagame != nil {
		edges = append(edges, gameaccount.EdgeSagame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case gameaccount.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	case gameaccount.EdgePgslot:
		ids := make([]ent.Value, 0, len(m.pgslot))
		for id := range m.pgslot {
			ids = append(ids, id)
		}
		return ids
	case gameaccount.EdgePretty:
		ids := make([]ent.Value, 0, len(m.pretty))
		for id := range m.pretty {
			ids = append(ids, id)
		}
		return ids
	case gameaccount.EdgeSagame:
		ids := make([]ent.Value, 0, len(m.sagame))
		for id := range m.sagame {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpgslot != nil {
		edges = append(edges, gameaccount.EdgePgslot)
	}
	if m.removedpretty != nil {
		edges = append(edges, gameaccount.EdgePretty)
	}
	if m.removedsagame != nil {
		edges = append(edges, gameaccount.EdgeSagame)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gameaccount.EdgePgslot:
		ids := make([]ent.Value, 0, len(m.removedpgslot))
		for id := range m.removedpgslot {
			ids = append(ids, id)
		}
		return ids
	case gameaccount.EdgePretty:
		ids := make([]ent.Value, 0, len(m.removedpretty))
		for id := range m.removedpretty {
			ids = append(ids, id)
		}
		return ids
	case gameaccount.EdgeSagame:
		ids := make([]ent.Value, 0, len(m.removedsagame))
		for id := range m.removedsagame {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, gameaccount.EdgeOwner)
	}
	if m.clearedgame {
		edges = append(edges, gameaccount.EdgeGame)
	}
	if m.clearedpgslot {
		edges = append(edges, gameaccount.EdgePgslot)
	}
	if m.clearedpretty {
		edges = append(edges, gameaccount.EdgePretty)
	}
	if m.clearedsagame {
		edges = append(edges, gameaccount.EdgeSagame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case gameaccount.EdgeOwner:
		return m.clearedowner
	case gameaccount.EdgeGame:
		return m.clearedgame
	case gameaccount.EdgePgslot:
		return m.clearedpgslot
	case gameaccount.EdgePretty:
		return m.clearedpretty
	case gameaccount.EdgeSagame:
		return m.clearedsagame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameAccountMutation) ClearEdge(name string) error {
	switch name {
	case gameaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	case gameaccount.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown GameAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameAccountMutation) ResetEdge(name string) error {
	switch name {
	case gameaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	case gameaccount.EdgeGame:
		m.ResetGame()
		return nil
	case gameaccount.EdgePgslot:
		m.ResetPgslot()
		return nil
	case gameaccount.EdgePretty:
		m.ResetPretty()
		return nil
	case gameaccount.EdgeSagame:
		m.ResetSagame()
		return nil
	}
	return fmt.Errorf("unknown GameAccount edge %s", name)
}

// LineAccountMutation represents an operation that mutates the LineAccount nodes in the graph.
type LineAccountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *uuid.UUID
	line_id        *string
	line_client_id *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *int
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*LineAccount, error)
	predicates     []predicate.LineAccount
}

var _ ent.Mutation = (*LineAccountMutation)(nil)

// lineaccountOption allows management of the mutation configuration using functional options.
type lineaccountOption func(*LineAccountMutation)

// newLineAccountMutation creates new mutation for the LineAccount entity.
func newLineAccountMutation(c config, op Op, opts ...lineaccountOption) *LineAccountMutation {
	m := &LineAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeLineAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLineAccountID sets the ID field of the mutation.
func withLineAccountID(id int) lineaccountOption {
	return func(m *LineAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *LineAccount
		)
		m.oldValue = func(ctx context.Context) (*LineAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LineAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLineAccount sets the old LineAccount of the mutation.
func withLineAccount(node *LineAccount) lineaccountOption {
	return func(m *LineAccountMutation) {
		m.oldValue = func(context.Context) (*LineAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LineAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LineAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LineAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *LineAccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *LineAccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the LineAccount entity.
// If the LineAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineAccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *LineAccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetLineID sets the "line_id" field.
func (m *LineAccountMutation) SetLineID(s string) {
	m.line_id = &s
}

// LineID returns the value of the "line_id" field in the mutation.
func (m *LineAccountMutation) LineID() (r string, exists bool) {
	v := m.line_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLineID returns the old "line_id" field's value of the LineAccount entity.
// If the LineAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineAccountMutation) OldLineID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineID: %w", err)
	}
	return oldValue.LineID, nil
}

// ResetLineID resets all changes to the "line_id" field.
func (m *LineAccountMutation) ResetLineID() {
	m.line_id = nil
}

// SetLineClientID sets the "line_client_id" field.
func (m *LineAccountMutation) SetLineClientID(s string) {
	m.line_client_id = &s
}

// LineClientID returns the value of the "line_client_id" field in the mutation.
func (m *LineAccountMutation) LineClientID() (r string, exists bool) {
	v := m.line_client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLineClientID returns the old "line_client_id" field's value of the LineAccount entity.
// If the LineAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineAccountMutation) OldLineClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLineClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLineClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineClientID: %w", err)
	}
	return oldValue.LineClientID, nil
}

// ClearLineClientID clears the value of the "line_client_id" field.
func (m *LineAccountMutation) ClearLineClientID() {
	m.line_client_id = nil
	m.clearedFields[lineaccount.FieldLineClientID] = struct{}{}
}

// LineClientIDCleared returns if the "line_client_id" field was cleared in this mutation.
func (m *LineAccountMutation) LineClientIDCleared() bool {
	_, ok := m.clearedFields[lineaccount.FieldLineClientID]
	return ok
}

// ResetLineClientID resets all changes to the "line_client_id" field.
func (m *LineAccountMutation) ResetLineClientID() {
	m.line_client_id = nil
	delete(m.clearedFields, lineaccount.FieldLineClientID)
}

// SetCreatedAt sets the "created_at" field.
func (m *LineAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LineAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LineAccount entity.
// If the LineAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LineAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LineAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LineAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LineAccount entity.
// If the LineAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LineAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *LineAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *LineAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *LineAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *LineAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *LineAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *LineAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the LineAccountMutation builder.
func (m *LineAccountMutation) Where(ps ...predicate.LineAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LineAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LineAccount).
func (m *LineAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LineAccountMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, lineaccount.FieldUUID)
	}
	if m.line_id != nil {
		fields = append(fields, lineaccount.FieldLineID)
	}
	if m.line_client_id != nil {
		fields = append(fields, lineaccount.FieldLineClientID)
	}
	if m.created_at != nil {
		fields = append(fields, lineaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lineaccount.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LineAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lineaccount.FieldUUID:
		return m.UUID()
	case lineaccount.FieldLineID:
		return m.LineID()
	case lineaccount.FieldLineClientID:
		return m.LineClientID()
	case lineaccount.FieldCreatedAt:
		return m.CreatedAt()
	case lineaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LineAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lineaccount.FieldUUID:
		return m.OldUUID(ctx)
	case lineaccount.FieldLineID:
		return m.OldLineID(ctx)
	case lineaccount.FieldLineClientID:
		return m.OldLineClientID(ctx)
	case lineaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lineaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LineAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LineAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lineaccount.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case lineaccount.FieldLineID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineID(v)
		return nil
	case lineaccount.FieldLineClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineClientID(v)
		return nil
	case lineaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lineaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LineAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LineAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LineAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LineAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LineAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LineAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lineaccount.FieldLineClientID) {
		fields = append(fields, lineaccount.FieldLineClientID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LineAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LineAccountMutation) ClearField(name string) error {
	switch name {
	case lineaccount.FieldLineClientID:
		m.ClearLineClientID()
		return nil
	}
	return fmt.Errorf("unknown LineAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LineAccountMutation) ResetField(name string) error {
	switch name {
	case lineaccount.FieldUUID:
		m.ResetUUID()
		return nil
	case lineaccount.FieldLineID:
		m.ResetLineID()
		return nil
	case lineaccount.FieldLineClientID:
		m.ResetLineClientID()
		return nil
	case lineaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lineaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LineAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LineAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, lineaccount.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LineAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lineaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LineAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LineAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LineAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, lineaccount.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LineAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case lineaccount.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LineAccountMutation) ClearEdge(name string) error {
	switch name {
	case lineaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown LineAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LineAccountMutation) ResetEdge(name string) error {
	switch name {
	case lineaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown LineAccount edge %s", name)
}

// MasterWalletTransactionMutation represents an operation that mutates the MasterWalletTransaction nodes in the graph.
type MasterWalletTransactionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	debit         *float32
	adddebit      *float32
	credit        *float32
	addcredit     *float32
	balance       *float32
	addbalance    *float32
	remark        *string
	txn_type      *masterwallettransaction.TxnType
	status        *masterwallettransaction.Status
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*MasterWalletTransaction, error)
	predicates    []predicate.MasterWalletTransaction
}

var _ ent.Mutation = (*MasterWalletTransactionMutation)(nil)

// masterwallettransactionOption allows management of the mutation configuration using functional options.
type masterwallettransactionOption func(*MasterWalletTransactionMutation)

// newMasterWalletTransactionMutation creates new mutation for the MasterWalletTransaction entity.
func newMasterWalletTransactionMutation(c config, op Op, opts ...masterwallettransactionOption) *MasterWalletTransactionMutation {
	m := &MasterWalletTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeMasterWalletTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMasterWalletTransactionID sets the ID field of the mutation.
func withMasterWalletTransactionID(id int) masterwallettransactionOption {
	return func(m *MasterWalletTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *MasterWalletTransaction
		)
		m.oldValue = func(ctx context.Context) (*MasterWalletTransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MasterWalletTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMasterWalletTransaction sets the old MasterWalletTransaction of the mutation.
func withMasterWalletTransaction(node *MasterWalletTransaction) masterwallettransactionOption {
	return func(m *MasterWalletTransactionMutation) {
		m.oldValue = func(context.Context) (*MasterWalletTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MasterWalletTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MasterWalletTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MasterWalletTransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MasterWalletTransactionMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MasterWalletTransactionMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MasterWalletTransactionMutation) ResetUUID() {
	m.uuid = nil
}

// SetDebit sets the "debit" field.
func (m *MasterWalletTransactionMutation) SetDebit(f float32) {
	m.debit = &f
	m.adddebit = nil
}

// Debit returns the value of the "debit" field in the mutation.
func (m *MasterWalletTransactionMutation) Debit() (r float32, exists bool) {
	v := m.debit
	if v == nil {
		return
	}
	return *v, true
}

// OldDebit returns the old "debit" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldDebit(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDebit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDebit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebit: %w", err)
	}
	return oldValue.Debit, nil
}

// AddDebit adds f to the "debit" field.
func (m *MasterWalletTransactionMutation) AddDebit(f float32) {
	if m.adddebit != nil {
		*m.adddebit += f
	} else {
		m.adddebit = &f
	}
}

// AddedDebit returns the value that was added to the "debit" field in this mutation.
func (m *MasterWalletTransactionMutation) AddedDebit() (r float32, exists bool) {
	v := m.adddebit
	if v == nil {
		return
	}
	return *v, true
}

// ResetDebit resets all changes to the "debit" field.
func (m *MasterWalletTransactionMutation) ResetDebit() {
	m.debit = nil
	m.adddebit = nil
}

// SetCredit sets the "credit" field.
func (m *MasterWalletTransactionMutation) SetCredit(f float32) {
	m.credit = &f
	m.addcredit = nil
}

// Credit returns the value of the "credit" field in the mutation.
func (m *MasterWalletTransactionMutation) Credit() (r float32, exists bool) {
	v := m.credit
	if v == nil {
		return
	}
	return *v, true
}

// OldCredit returns the old "credit" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldCredit(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCredit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCredit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredit: %w", err)
	}
	return oldValue.Credit, nil
}

// AddCredit adds f to the "credit" field.
func (m *MasterWalletTransactionMutation) AddCredit(f float32) {
	if m.addcredit != nil {
		*m.addcredit += f
	} else {
		m.addcredit = &f
	}
}

// AddedCredit returns the value that was added to the "credit" field in this mutation.
func (m *MasterWalletTransactionMutation) AddedCredit() (r float32, exists bool) {
	v := m.addcredit
	if v == nil {
		return
	}
	return *v, true
}

// ResetCredit resets all changes to the "credit" field.
func (m *MasterWalletTransactionMutation) ResetCredit() {
	m.credit = nil
	m.addcredit = nil
}

// SetBalance sets the "balance" field.
func (m *MasterWalletTransactionMutation) SetBalance(f float32) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *MasterWalletTransactionMutation) Balance() (r float32, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldBalance(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *MasterWalletTransactionMutation) AddBalance(f float32) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *MasterWalletTransactionMutation) AddedBalance() (r float32, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *MasterWalletTransactionMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetRemark sets the "remark" field.
func (m *MasterWalletTransactionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MasterWalletTransactionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MasterWalletTransactionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[masterwallettransaction.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MasterWalletTransactionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[masterwallettransaction.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MasterWalletTransactionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, masterwallettransaction.FieldRemark)
}

// SetTxnType sets the "txn_type" field.
func (m *MasterWalletTransactionMutation) SetTxnType(mt masterwallettransaction.TxnType) {
	m.txn_type = &mt
}

// TxnType returns the value of the "txn_type" field in the mutation.
func (m *MasterWalletTransactionMutation) TxnType() (r masterwallettransaction.TxnType, exists bool) {
	v := m.txn_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTxnType returns the old "txn_type" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldTxnType(ctx context.Context) (v masterwallettransaction.TxnType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxnType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxnType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxnType: %w", err)
	}
	return oldValue.TxnType, nil
}

// ResetTxnType resets all changes to the "txn_type" field.
func (m *MasterWalletTransactionMutation) ResetTxnType() {
	m.txn_type = nil
}

// SetStatus sets the "status" field.
func (m *MasterWalletTransactionMutation) SetStatus(value masterwallettransaction.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MasterWalletTransactionMutation) Status() (r masterwallettransaction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldStatus(ctx context.Context) (v masterwallettransaction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MasterWalletTransactionMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MasterWalletTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MasterWalletTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MasterWalletTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MasterWalletTransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MasterWalletTransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MasterWalletTransaction entity.
// If the MasterWalletTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterWalletTransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MasterWalletTransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *MasterWalletTransactionMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *MasterWalletTransactionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *MasterWalletTransactionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MasterWalletTransactionMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MasterWalletTransactionMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MasterWalletTransactionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MasterWalletTransactionMutation builder.
func (m *MasterWalletTransactionMutation) Where(ps ...predicate.MasterWalletTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MasterWalletTransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MasterWalletTransaction).
func (m *MasterWalletTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MasterWalletTransactionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, masterwallettransaction.FieldUUID)
	}
	if m.debit != nil {
		fields = append(fields, masterwallettransaction.FieldDebit)
	}
	if m.credit != nil {
		fields = append(fields, masterwallettransaction.FieldCredit)
	}
	if m.balance != nil {
		fields = append(fields, masterwallettransaction.FieldBalance)
	}
	if m.remark != nil {
		fields = append(fields, masterwallettransaction.FieldRemark)
	}
	if m.txn_type != nil {
		fields = append(fields, masterwallettransaction.FieldTxnType)
	}
	if m.status != nil {
		fields = append(fields, masterwallettransaction.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, masterwallettransaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, masterwallettransaction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MasterWalletTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case masterwallettransaction.FieldUUID:
		return m.UUID()
	case masterwallettransaction.FieldDebit:
		return m.Debit()
	case masterwallettransaction.FieldCredit:
		return m.Credit()
	case masterwallettransaction.FieldBalance:
		return m.Balance()
	case masterwallettransaction.FieldRemark:
		return m.Remark()
	case masterwallettransaction.FieldTxnType:
		return m.TxnType()
	case masterwallettransaction.FieldStatus:
		return m.Status()
	case masterwallettransaction.FieldCreatedAt:
		return m.CreatedAt()
	case masterwallettransaction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MasterWalletTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case masterwallettransaction.FieldUUID:
		return m.OldUUID(ctx)
	case masterwallettransaction.FieldDebit:
		return m.OldDebit(ctx)
	case masterwallettransaction.FieldCredit:
		return m.OldCredit(ctx)
	case masterwallettransaction.FieldBalance:
		return m.OldBalance(ctx)
	case masterwallettransaction.FieldRemark:
		return m.OldRemark(ctx)
	case masterwallettransaction.FieldTxnType:
		return m.OldTxnType(ctx)
	case masterwallettransaction.FieldStatus:
		return m.OldStatus(ctx)
	case masterwallettransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case masterwallettransaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MasterWalletTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterWalletTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case masterwallettransaction.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case masterwallettransaction.FieldDebit:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebit(v)
		return nil
	case masterwallettransaction.FieldCredit:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredit(v)
		return nil
	case masterwallettransaction.FieldBalance:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case masterwallettransaction.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case masterwallettransaction.FieldTxnType:
		v, ok := value.(masterwallettransaction.TxnType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxnType(v)
		return nil
	case masterwallettransaction.FieldStatus:
		v, ok := value.(masterwallettransaction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case masterwallettransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case masterwallettransaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MasterWalletTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MasterWalletTransactionMutation) AddedFields() []string {
	var fields []string
	if m.adddebit != nil {
		fields = append(fields, masterwallettransaction.FieldDebit)
	}
	if m.addcredit != nil {
		fields = append(fields, masterwallettransaction.FieldCredit)
	}
	if m.addbalance != nil {
		fields = append(fields, masterwallettransaction.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MasterWalletTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case masterwallettransaction.FieldDebit:
		return m.AddedDebit()
	case masterwallettransaction.FieldCredit:
		return m.AddedCredit()
	case masterwallettransaction.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterWalletTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case masterwallettransaction.FieldDebit:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDebit(v)
		return nil
	case masterwallettransaction.FieldCredit:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCredit(v)
		return nil
	case masterwallettransaction.FieldBalance:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown MasterWalletTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MasterWalletTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(masterwallettransaction.FieldRemark) {
		fields = append(fields, masterwallettransaction.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MasterWalletTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MasterWalletTransactionMutation) ClearField(name string) error {
	switch name {
	case masterwallettransaction.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown MasterWalletTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MasterWalletTransactionMutation) ResetField(name string) error {
	switch name {
	case masterwallettransaction.FieldUUID:
		m.ResetUUID()
		return nil
	case masterwallettransaction.FieldDebit:
		m.ResetDebit()
		return nil
	case masterwallettransaction.FieldCredit:
		m.ResetCredit()
		return nil
	case masterwallettransaction.FieldBalance:
		m.ResetBalance()
		return nil
	case masterwallettransaction.FieldRemark:
		m.ResetRemark()
		return nil
	case masterwallettransaction.FieldTxnType:
		m.ResetTxnType()
		return nil
	case masterwallettransaction.FieldStatus:
		m.ResetStatus()
		return nil
	case masterwallettransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case masterwallettransaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MasterWalletTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MasterWalletTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, masterwallettransaction.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MasterWalletTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case masterwallettransaction.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MasterWalletTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MasterWalletTransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MasterWalletTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, masterwallettransaction.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MasterWalletTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case masterwallettransaction.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MasterWalletTransactionMutation) ClearEdge(name string) error {
	switch name {
	case masterwallettransaction.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown MasterWalletTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MasterWalletTransactionMutation) ResetEdge(name string) error {
	switch name {
	case masterwallettransaction.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown MasterWalletTransaction edge %s", name)
}

// PgSlotAccountMutation represents an operation that mutates the PgSlotAccount nodes in the graph.
type PgSlotAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	username      *string
	password      *string
	desktop_uri   *string
	mobile_uri    *string
	created_at    *time.Time
	updated_at    *time.Time
	raw_data      *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PgSlotAccount, error)
	predicates    []predicate.PgSlotAccount
}

var _ ent.Mutation = (*PgSlotAccountMutation)(nil)

// pgslotaccountOption allows management of the mutation configuration using functional options.
type pgslotaccountOption func(*PgSlotAccountMutation)

// newPgSlotAccountMutation creates new mutation for the PgSlotAccount entity.
func newPgSlotAccountMutation(c config, op Op, opts ...pgslotaccountOption) *PgSlotAccountMutation {
	m := &PgSlotAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePgSlotAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPgSlotAccountID sets the ID field of the mutation.
func withPgSlotAccountID(id int) pgslotaccountOption {
	return func(m *PgSlotAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PgSlotAccount
		)
		m.oldValue = func(ctx context.Context) (*PgSlotAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PgSlotAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPgSlotAccount sets the old PgSlotAccount of the mutation.
func withPgSlotAccount(node *PgSlotAccount) pgslotaccountOption {
	return func(m *PgSlotAccountMutation) {
		m.oldValue = func(context.Context) (*PgSlotAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PgSlotAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PgSlotAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PgSlotAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PgSlotAccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PgSlotAccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PgSlotAccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetUsername sets the "username" field.
func (m *PgSlotAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *PgSlotAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *PgSlotAccountMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[pgslotaccount.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *PgSlotAccountMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[pgslotaccount.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *PgSlotAccountMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, pgslotaccount.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *PgSlotAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *PgSlotAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *PgSlotAccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[pgslotaccount.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *PgSlotAccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[pgslotaccount.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *PgSlotAccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, pgslotaccount.FieldPassword)
}

// SetDesktopURI sets the "desktop_uri" field.
func (m *PgSlotAccountMutation) SetDesktopURI(s string) {
	m.desktop_uri = &s
}

// DesktopURI returns the value of the "desktop_uri" field in the mutation.
func (m *PgSlotAccountMutation) DesktopURI() (r string, exists bool) {
	v := m.desktop_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldDesktopURI returns the old "desktop_uri" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldDesktopURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesktopURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesktopURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesktopURI: %w", err)
	}
	return oldValue.DesktopURI, nil
}

// ClearDesktopURI clears the value of the "desktop_uri" field.
func (m *PgSlotAccountMutation) ClearDesktopURI() {
	m.desktop_uri = nil
	m.clearedFields[pgslotaccount.FieldDesktopURI] = struct{}{}
}

// DesktopURICleared returns if the "desktop_uri" field was cleared in this mutation.
func (m *PgSlotAccountMutation) DesktopURICleared() bool {
	_, ok := m.clearedFields[pgslotaccount.FieldDesktopURI]
	return ok
}

// ResetDesktopURI resets all changes to the "desktop_uri" field.
func (m *PgSlotAccountMutation) ResetDesktopURI() {
	m.desktop_uri = nil
	delete(m.clearedFields, pgslotaccount.FieldDesktopURI)
}

// SetMobileURI sets the "mobile_uri" field.
func (m *PgSlotAccountMutation) SetMobileURI(s string) {
	m.mobile_uri = &s
}

// MobileURI returns the value of the "mobile_uri" field in the mutation.
func (m *PgSlotAccountMutation) MobileURI() (r string, exists bool) {
	v := m.mobile_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileURI returns the old "mobile_uri" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldMobileURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileURI: %w", err)
	}
	return oldValue.MobileURI, nil
}

// ClearMobileURI clears the value of the "mobile_uri" field.
func (m *PgSlotAccountMutation) ClearMobileURI() {
	m.mobile_uri = nil
	m.clearedFields[pgslotaccount.FieldMobileURI] = struct{}{}
}

// MobileURICleared returns if the "mobile_uri" field was cleared in this mutation.
func (m *PgSlotAccountMutation) MobileURICleared() bool {
	_, ok := m.clearedFields[pgslotaccount.FieldMobileURI]
	return ok
}

// ResetMobileURI resets all changes to the "mobile_uri" field.
func (m *PgSlotAccountMutation) ResetMobileURI() {
	m.mobile_uri = nil
	delete(m.clearedFields, pgslotaccount.FieldMobileURI)
}

// SetCreatedAt sets the "created_at" field.
func (m *PgSlotAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PgSlotAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PgSlotAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PgSlotAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PgSlotAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PgSlotAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRawData sets the "raw_data" field.
func (m *PgSlotAccountMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *PgSlotAccountMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the PgSlotAccount entity.
// If the PgSlotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgSlotAccountMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *PgSlotAccountMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[pgslotaccount.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *PgSlotAccountMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[pgslotaccount.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *PgSlotAccountMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, pgslotaccount.FieldRawData)
}

// SetOwnerID sets the "owner" edge to the GameAccount entity by id.
func (m *PgSlotAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the GameAccount entity.
func (m *PgSlotAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the GameAccount entity was cleared.
func (m *PgSlotAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PgSlotAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PgSlotAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PgSlotAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PgSlotAccountMutation builder.
func (m *PgSlotAccountMutation) Where(ps ...predicate.PgSlotAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PgSlotAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PgSlotAccount).
func (m *PgSlotAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PgSlotAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, pgslotaccount.FieldUUID)
	}
	if m.username != nil {
		fields = append(fields, pgslotaccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, pgslotaccount.FieldPassword)
	}
	if m.desktop_uri != nil {
		fields = append(fields, pgslotaccount.FieldDesktopURI)
	}
	if m.mobile_uri != nil {
		fields = append(fields, pgslotaccount.FieldMobileURI)
	}
	if m.created_at != nil {
		fields = append(fields, pgslotaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pgslotaccount.FieldUpdatedAt)
	}
	if m.raw_data != nil {
		fields = append(fields, pgslotaccount.FieldRawData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PgSlotAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pgslotaccount.FieldUUID:
		return m.UUID()
	case pgslotaccount.FieldUsername:
		return m.Username()
	case pgslotaccount.FieldPassword:
		return m.Password()
	case pgslotaccount.FieldDesktopURI:
		return m.DesktopURI()
	case pgslotaccount.FieldMobileURI:
		return m.MobileURI()
	case pgslotaccount.FieldCreatedAt:
		return m.CreatedAt()
	case pgslotaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case pgslotaccount.FieldRawData:
		return m.RawData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PgSlotAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pgslotaccount.FieldUUID:
		return m.OldUUID(ctx)
	case pgslotaccount.FieldUsername:
		return m.OldUsername(ctx)
	case pgslotaccount.FieldPassword:
		return m.OldPassword(ctx)
	case pgslotaccount.FieldDesktopURI:
		return m.OldDesktopURI(ctx)
	case pgslotaccount.FieldMobileURI:
		return m.OldMobileURI(ctx)
	case pgslotaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pgslotaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pgslotaccount.FieldRawData:
		return m.OldRawData(ctx)
	}
	return nil, fmt.Errorf("unknown PgSlotAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PgSlotAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pgslotaccount.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case pgslotaccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case pgslotaccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case pgslotaccount.FieldDesktopURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesktopURI(v)
		return nil
	case pgslotaccount.FieldMobileURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileURI(v)
		return nil
	case pgslotaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pgslotaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pgslotaccount.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	}
	return fmt.Errorf("unknown PgSlotAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PgSlotAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PgSlotAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PgSlotAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PgSlotAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PgSlotAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pgslotaccount.FieldUsername) {
		fields = append(fields, pgslotaccount.FieldUsername)
	}
	if m.FieldCleared(pgslotaccount.FieldPassword) {
		fields = append(fields, pgslotaccount.FieldPassword)
	}
	if m.FieldCleared(pgslotaccount.FieldDesktopURI) {
		fields = append(fields, pgslotaccount.FieldDesktopURI)
	}
	if m.FieldCleared(pgslotaccount.FieldMobileURI) {
		fields = append(fields, pgslotaccount.FieldMobileURI)
	}
	if m.FieldCleared(pgslotaccount.FieldRawData) {
		fields = append(fields, pgslotaccount.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PgSlotAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PgSlotAccountMutation) ClearField(name string) error {
	switch name {
	case pgslotaccount.FieldUsername:
		m.ClearUsername()
		return nil
	case pgslotaccount.FieldPassword:
		m.ClearPassword()
		return nil
	case pgslotaccount.FieldDesktopURI:
		m.ClearDesktopURI()
		return nil
	case pgslotaccount.FieldMobileURI:
		m.ClearMobileURI()
		return nil
	case pgslotaccount.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown PgSlotAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PgSlotAccountMutation) ResetField(name string) error {
	switch name {
	case pgslotaccount.FieldUUID:
		m.ResetUUID()
		return nil
	case pgslotaccount.FieldUsername:
		m.ResetUsername()
		return nil
	case pgslotaccount.FieldPassword:
		m.ResetPassword()
		return nil
	case pgslotaccount.FieldDesktopURI:
		m.ResetDesktopURI()
		return nil
	case pgslotaccount.FieldMobileURI:
		m.ResetMobileURI()
		return nil
	case pgslotaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pgslotaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pgslotaccount.FieldRawData:
		m.ResetRawData()
		return nil
	}
	return fmt.Errorf("unknown PgSlotAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PgSlotAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, pgslotaccount.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PgSlotAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pgslotaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PgSlotAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PgSlotAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PgSlotAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, pgslotaccount.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PgSlotAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case pgslotaccount.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PgSlotAccountMutation) ClearEdge(name string) error {
	switch name {
	case pgslotaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PgSlotAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PgSlotAccountMutation) ResetEdge(name string) error {
	switch name {
	case pgslotaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PgSlotAccount edge %s", name)
}

// PrettyGameAccountMutation represents an operation that mutates the PrettyGameAccount nodes in the graph.
type PrettyGameAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	username      *string
	password      *string
	desktop_uri   *string
	mobile_uri    *string
	created_at    *time.Time
	updated_at    *time.Time
	raw_data      *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PrettyGameAccount, error)
	predicates    []predicate.PrettyGameAccount
}

var _ ent.Mutation = (*PrettyGameAccountMutation)(nil)

// prettygameaccountOption allows management of the mutation configuration using functional options.
type prettygameaccountOption func(*PrettyGameAccountMutation)

// newPrettyGameAccountMutation creates new mutation for the PrettyGameAccount entity.
func newPrettyGameAccountMutation(c config, op Op, opts ...prettygameaccountOption) *PrettyGameAccountMutation {
	m := &PrettyGameAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePrettyGameAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrettyGameAccountID sets the ID field of the mutation.
func withPrettyGameAccountID(id int) prettygameaccountOption {
	return func(m *PrettyGameAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PrettyGameAccount
		)
		m.oldValue = func(ctx context.Context) (*PrettyGameAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrettyGameAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrettyGameAccount sets the old PrettyGameAccount of the mutation.
func withPrettyGameAccount(node *PrettyGameAccount) prettygameaccountOption {
	return func(m *PrettyGameAccountMutation) {
		m.oldValue = func(context.Context) (*PrettyGameAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrettyGameAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrettyGameAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrettyGameAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PrettyGameAccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PrettyGameAccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PrettyGameAccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetUsername sets the "username" field.
func (m *PrettyGameAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *PrettyGameAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *PrettyGameAccountMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[prettygameaccount.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *PrettyGameAccountMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[prettygameaccount.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *PrettyGameAccountMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, prettygameaccount.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *PrettyGameAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *PrettyGameAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *PrettyGameAccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[prettygameaccount.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *PrettyGameAccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[prettygameaccount.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *PrettyGameAccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, prettygameaccount.FieldPassword)
}

// SetDesktopURI sets the "desktop_uri" field.
func (m *PrettyGameAccountMutation) SetDesktopURI(s string) {
	m.desktop_uri = &s
}

// DesktopURI returns the value of the "desktop_uri" field in the mutation.
func (m *PrettyGameAccountMutation) DesktopURI() (r string, exists bool) {
	v := m.desktop_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldDesktopURI returns the old "desktop_uri" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldDesktopURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesktopURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesktopURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesktopURI: %w", err)
	}
	return oldValue.DesktopURI, nil
}

// ClearDesktopURI clears the value of the "desktop_uri" field.
func (m *PrettyGameAccountMutation) ClearDesktopURI() {
	m.desktop_uri = nil
	m.clearedFields[prettygameaccount.FieldDesktopURI] = struct{}{}
}

// DesktopURICleared returns if the "desktop_uri" field was cleared in this mutation.
func (m *PrettyGameAccountMutation) DesktopURICleared() bool {
	_, ok := m.clearedFields[prettygameaccount.FieldDesktopURI]
	return ok
}

// ResetDesktopURI resets all changes to the "desktop_uri" field.
func (m *PrettyGameAccountMutation) ResetDesktopURI() {
	m.desktop_uri = nil
	delete(m.clearedFields, prettygameaccount.FieldDesktopURI)
}

// SetMobileURI sets the "mobile_uri" field.
func (m *PrettyGameAccountMutation) SetMobileURI(s string) {
	m.mobile_uri = &s
}

// MobileURI returns the value of the "mobile_uri" field in the mutation.
func (m *PrettyGameAccountMutation) MobileURI() (r string, exists bool) {
	v := m.mobile_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileURI returns the old "mobile_uri" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldMobileURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileURI: %w", err)
	}
	return oldValue.MobileURI, nil
}

// ClearMobileURI clears the value of the "mobile_uri" field.
func (m *PrettyGameAccountMutation) ClearMobileURI() {
	m.mobile_uri = nil
	m.clearedFields[prettygameaccount.FieldMobileURI] = struct{}{}
}

// MobileURICleared returns if the "mobile_uri" field was cleared in this mutation.
func (m *PrettyGameAccountMutation) MobileURICleared() bool {
	_, ok := m.clearedFields[prettygameaccount.FieldMobileURI]
	return ok
}

// ResetMobileURI resets all changes to the "mobile_uri" field.
func (m *PrettyGameAccountMutation) ResetMobileURI() {
	m.mobile_uri = nil
	delete(m.clearedFields, prettygameaccount.FieldMobileURI)
}

// SetCreatedAt sets the "created_at" field.
func (m *PrettyGameAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PrettyGameAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PrettyGameAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PrettyGameAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PrettyGameAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PrettyGameAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRawData sets the "raw_data" field.
func (m *PrettyGameAccountMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *PrettyGameAccountMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the PrettyGameAccount entity.
// If the PrettyGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrettyGameAccountMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *PrettyGameAccountMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[prettygameaccount.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *PrettyGameAccountMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[prettygameaccount.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *PrettyGameAccountMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, prettygameaccount.FieldRawData)
}

// SetOwnerID sets the "owner" edge to the GameAccount entity by id.
func (m *PrettyGameAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the GameAccount entity.
func (m *PrettyGameAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the GameAccount entity was cleared.
func (m *PrettyGameAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PrettyGameAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PrettyGameAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PrettyGameAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PrettyGameAccountMutation builder.
func (m *PrettyGameAccountMutation) Where(ps ...predicate.PrettyGameAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PrettyGameAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PrettyGameAccount).
func (m *PrettyGameAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrettyGameAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, prettygameaccount.FieldUUID)
	}
	if m.username != nil {
		fields = append(fields, prettygameaccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, prettygameaccount.FieldPassword)
	}
	if m.desktop_uri != nil {
		fields = append(fields, prettygameaccount.FieldDesktopURI)
	}
	if m.mobile_uri != nil {
		fields = append(fields, prettygameaccount.FieldMobileURI)
	}
	if m.created_at != nil {
		fields = append(fields, prettygameaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prettygameaccount.FieldUpdatedAt)
	}
	if m.raw_data != nil {
		fields = append(fields, prettygameaccount.FieldRawData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrettyGameAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prettygameaccount.FieldUUID:
		return m.UUID()
	case prettygameaccount.FieldUsername:
		return m.Username()
	case prettygameaccount.FieldPassword:
		return m.Password()
	case prettygameaccount.FieldDesktopURI:
		return m.DesktopURI()
	case prettygameaccount.FieldMobileURI:
		return m.MobileURI()
	case prettygameaccount.FieldCreatedAt:
		return m.CreatedAt()
	case prettygameaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case prettygameaccount.FieldRawData:
		return m.RawData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrettyGameAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prettygameaccount.FieldUUID:
		return m.OldUUID(ctx)
	case prettygameaccount.FieldUsername:
		return m.OldUsername(ctx)
	case prettygameaccount.FieldPassword:
		return m.OldPassword(ctx)
	case prettygameaccount.FieldDesktopURI:
		return m.OldDesktopURI(ctx)
	case prettygameaccount.FieldMobileURI:
		return m.OldMobileURI(ctx)
	case prettygameaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prettygameaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prettygameaccount.FieldRawData:
		return m.OldRawData(ctx)
	}
	return nil, fmt.Errorf("unknown PrettyGameAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrettyGameAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prettygameaccount.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case prettygameaccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case prettygameaccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case prettygameaccount.FieldDesktopURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesktopURI(v)
		return nil
	case prettygameaccount.FieldMobileURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileURI(v)
		return nil
	case prettygameaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prettygameaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prettygameaccount.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	}
	return fmt.Errorf("unknown PrettyGameAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrettyGameAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrettyGameAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrettyGameAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrettyGameAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrettyGameAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prettygameaccount.FieldUsername) {
		fields = append(fields, prettygameaccount.FieldUsername)
	}
	if m.FieldCleared(prettygameaccount.FieldPassword) {
		fields = append(fields, prettygameaccount.FieldPassword)
	}
	if m.FieldCleared(prettygameaccount.FieldDesktopURI) {
		fields = append(fields, prettygameaccount.FieldDesktopURI)
	}
	if m.FieldCleared(prettygameaccount.FieldMobileURI) {
		fields = append(fields, prettygameaccount.FieldMobileURI)
	}
	if m.FieldCleared(prettygameaccount.FieldRawData) {
		fields = append(fields, prettygameaccount.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrettyGameAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrettyGameAccountMutation) ClearField(name string) error {
	switch name {
	case prettygameaccount.FieldUsername:
		m.ClearUsername()
		return nil
	case prettygameaccount.FieldPassword:
		m.ClearPassword()
		return nil
	case prettygameaccount.FieldDesktopURI:
		m.ClearDesktopURI()
		return nil
	case prettygameaccount.FieldMobileURI:
		m.ClearMobileURI()
		return nil
	case prettygameaccount.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown PrettyGameAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrettyGameAccountMutation) ResetField(name string) error {
	switch name {
	case prettygameaccount.FieldUUID:
		m.ResetUUID()
		return nil
	case prettygameaccount.FieldUsername:
		m.ResetUsername()
		return nil
	case prettygameaccount.FieldPassword:
		m.ResetPassword()
		return nil
	case prettygameaccount.FieldDesktopURI:
		m.ResetDesktopURI()
		return nil
	case prettygameaccount.FieldMobileURI:
		m.ResetMobileURI()
		return nil
	case prettygameaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prettygameaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prettygameaccount.FieldRawData:
		m.ResetRawData()
		return nil
	}
	return fmt.Errorf("unknown PrettyGameAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrettyGameAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, prettygameaccount.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrettyGameAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prettygameaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrettyGameAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrettyGameAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrettyGameAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, prettygameaccount.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrettyGameAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case prettygameaccount.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrettyGameAccountMutation) ClearEdge(name string) error {
	switch name {
	case prettygameaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PrettyGameAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrettyGameAccountMutation) ResetEdge(name string) error {
	switch name {
	case prettygameaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PrettyGameAccount edge %s", name)
}

// SAGameAccountMutation represents an operation that mutates the SAGameAccount nodes in the graph.
type SAGameAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	username      *string
	password      *string
	desktop_uri   *string
	mobile_uri    *string
	created_at    *time.Time
	updated_at    *time.Time
	raw_data      *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*SAGameAccount, error)
	predicates    []predicate.SAGameAccount
}

var _ ent.Mutation = (*SAGameAccountMutation)(nil)

// sagameaccountOption allows management of the mutation configuration using functional options.
type sagameaccountOption func(*SAGameAccountMutation)

// newSAGameAccountMutation creates new mutation for the SAGameAccount entity.
func newSAGameAccountMutation(c config, op Op, opts ...sagameaccountOption) *SAGameAccountMutation {
	m := &SAGameAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeSAGameAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSAGameAccountID sets the ID field of the mutation.
func withSAGameAccountID(id int) sagameaccountOption {
	return func(m *SAGameAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *SAGameAccount
		)
		m.oldValue = func(ctx context.Context) (*SAGameAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SAGameAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSAGameAccount sets the old SAGameAccount of the mutation.
func withSAGameAccount(node *SAGameAccount) sagameaccountOption {
	return func(m *SAGameAccountMutation) {
		m.oldValue = func(context.Context) (*SAGameAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SAGameAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SAGameAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SAGameAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *SAGameAccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *SAGameAccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *SAGameAccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetUsername sets the "username" field.
func (m *SAGameAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SAGameAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *SAGameAccountMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[sagameaccount.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *SAGameAccountMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[sagameaccount.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *SAGameAccountMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, sagameaccount.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *SAGameAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *SAGameAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *SAGameAccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[sagameaccount.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *SAGameAccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[sagameaccount.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *SAGameAccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, sagameaccount.FieldPassword)
}

// SetDesktopURI sets the "desktop_uri" field.
func (m *SAGameAccountMutation) SetDesktopURI(s string) {
	m.desktop_uri = &s
}

// DesktopURI returns the value of the "desktop_uri" field in the mutation.
func (m *SAGameAccountMutation) DesktopURI() (r string, exists bool) {
	v := m.desktop_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldDesktopURI returns the old "desktop_uri" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldDesktopURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesktopURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesktopURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesktopURI: %w", err)
	}
	return oldValue.DesktopURI, nil
}

// ClearDesktopURI clears the value of the "desktop_uri" field.
func (m *SAGameAccountMutation) ClearDesktopURI() {
	m.desktop_uri = nil
	m.clearedFields[sagameaccount.FieldDesktopURI] = struct{}{}
}

// DesktopURICleared returns if the "desktop_uri" field was cleared in this mutation.
func (m *SAGameAccountMutation) DesktopURICleared() bool {
	_, ok := m.clearedFields[sagameaccount.FieldDesktopURI]
	return ok
}

// ResetDesktopURI resets all changes to the "desktop_uri" field.
func (m *SAGameAccountMutation) ResetDesktopURI() {
	m.desktop_uri = nil
	delete(m.clearedFields, sagameaccount.FieldDesktopURI)
}

// SetMobileURI sets the "mobile_uri" field.
func (m *SAGameAccountMutation) SetMobileURI(s string) {
	m.mobile_uri = &s
}

// MobileURI returns the value of the "mobile_uri" field in the mutation.
func (m *SAGameAccountMutation) MobileURI() (r string, exists bool) {
	v := m.mobile_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileURI returns the old "mobile_uri" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldMobileURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileURI: %w", err)
	}
	return oldValue.MobileURI, nil
}

// ClearMobileURI clears the value of the "mobile_uri" field.
func (m *SAGameAccountMutation) ClearMobileURI() {
	m.mobile_uri = nil
	m.clearedFields[sagameaccount.FieldMobileURI] = struct{}{}
}

// MobileURICleared returns if the "mobile_uri" field was cleared in this mutation.
func (m *SAGameAccountMutation) MobileURICleared() bool {
	_, ok := m.clearedFields[sagameaccount.FieldMobileURI]
	return ok
}

// ResetMobileURI resets all changes to the "mobile_uri" field.
func (m *SAGameAccountMutation) ResetMobileURI() {
	m.mobile_uri = nil
	delete(m.clearedFields, sagameaccount.FieldMobileURI)
}

// SetCreatedAt sets the "created_at" field.
func (m *SAGameAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SAGameAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SAGameAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SAGameAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SAGameAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SAGameAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRawData sets the "raw_data" field.
func (m *SAGameAccountMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *SAGameAccountMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the SAGameAccount entity.
// If the SAGameAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SAGameAccountMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *SAGameAccountMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[sagameaccount.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *SAGameAccountMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[sagameaccount.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *SAGameAccountMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, sagameaccount.FieldRawData)
}

// SetOwnerID sets the "owner" edge to the GameAccount entity by id.
func (m *SAGameAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the GameAccount entity.
func (m *SAGameAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the GameAccount entity was cleared.
func (m *SAGameAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SAGameAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SAGameAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SAGameAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SAGameAccountMutation builder.
func (m *SAGameAccountMutation) Where(ps ...predicate.SAGameAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SAGameAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SAGameAccount).
func (m *SAGameAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SAGameAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, sagameaccount.FieldUUID)
	}
	if m.username != nil {
		fields = append(fields, sagameaccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, sagameaccount.FieldPassword)
	}
	if m.desktop_uri != nil {
		fields = append(fields, sagameaccount.FieldDesktopURI)
	}
	if m.mobile_uri != nil {
		fields = append(fields, sagameaccount.FieldMobileURI)
	}
	if m.created_at != nil {
		fields = append(fields, sagameaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagameaccount.FieldUpdatedAt)
	}
	if m.raw_data != nil {
		fields = append(fields, sagameaccount.FieldRawData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SAGameAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagameaccount.FieldUUID:
		return m.UUID()
	case sagameaccount.FieldUsername:
		return m.Username()
	case sagameaccount.FieldPassword:
		return m.Password()
	case sagameaccount.FieldDesktopURI:
		return m.DesktopURI()
	case sagameaccount.FieldMobileURI:
		return m.MobileURI()
	case sagameaccount.FieldCreatedAt:
		return m.CreatedAt()
	case sagameaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case sagameaccount.FieldRawData:
		return m.RawData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SAGameAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagameaccount.FieldUUID:
		return m.OldUUID(ctx)
	case sagameaccount.FieldUsername:
		return m.OldUsername(ctx)
	case sagameaccount.FieldPassword:
		return m.OldPassword(ctx)
	case sagameaccount.FieldDesktopURI:
		return m.OldDesktopURI(ctx)
	case sagameaccount.FieldMobileURI:
		return m.OldMobileURI(ctx)
	case sagameaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sagameaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sagameaccount.FieldRawData:
		return m.OldRawData(ctx)
	}
	return nil, fmt.Errorf("unknown SAGameAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SAGameAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagameaccount.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case sagameaccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case sagameaccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case sagameaccount.FieldDesktopURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesktopURI(v)
		return nil
	case sagameaccount.FieldMobileURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileURI(v)
		return nil
	case sagameaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sagameaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sagameaccount.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	}
	return fmt.Errorf("unknown SAGameAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SAGameAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SAGameAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SAGameAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SAGameAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SAGameAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagameaccount.FieldUsername) {
		fields = append(fields, sagameaccount.FieldUsername)
	}
	if m.FieldCleared(sagameaccount.FieldPassword) {
		fields = append(fields, sagameaccount.FieldPassword)
	}
	if m.FieldCleared(sagameaccount.FieldDesktopURI) {
		fields = append(fields, sagameaccount.FieldDesktopURI)
	}
	if m.FieldCleared(sagameaccount.FieldMobileURI) {
		fields = append(fields, sagameaccount.FieldMobileURI)
	}
	if m.FieldCleared(sagameaccount.FieldRawData) {
		fields = append(fields, sagameaccount.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SAGameAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SAGameAccountMutation) ClearField(name string) error {
	switch name {
	case sagameaccount.FieldUsername:
		m.ClearUsername()
		return nil
	case sagameaccount.FieldPassword:
		m.ClearPassword()
		return nil
	case sagameaccount.FieldDesktopURI:
		m.ClearDesktopURI()
		return nil
	case sagameaccount.FieldMobileURI:
		m.ClearMobileURI()
		return nil
	case sagameaccount.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown SAGameAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SAGameAccountMutation) ResetField(name string) error {
	switch name {
	case sagameaccount.FieldUUID:
		m.ResetUUID()
		return nil
	case sagameaccount.FieldUsername:
		m.ResetUsername()
		return nil
	case sagameaccount.FieldPassword:
		m.ResetPassword()
		return nil
	case sagameaccount.FieldDesktopURI:
		m.ResetDesktopURI()
		return nil
	case sagameaccount.FieldMobileURI:
		m.ResetMobileURI()
		return nil
	case sagameaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sagameaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sagameaccount.FieldRawData:
		m.ResetRawData()
		return nil
	}
	return fmt.Errorf("unknown SAGameAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SAGameAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, sagameaccount.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SAGameAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagameaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SAGameAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SAGameAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SAGameAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, sagameaccount.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SAGameAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case sagameaccount.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SAGameAccountMutation) ClearEdge(name string) error {
	switch name {
	case sagameaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown SAGameAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SAGameAccountMutation) ResetEdge(name string) error {
	switch name {
	case sagameaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown SAGameAccount edge %s", name)
}

// TransferTransactionMutation represents an operation that mutates the TransferTransaction nodes in the graph.
type TransferTransactionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	amount        *float32
	addamount     *float32
	status        *transfertransaction.Status
	txn_type      *transfertransaction.TxnType
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	game          *int
	clearedgame   bool
	done          bool
	oldValue      func(context.Context) (*TransferTransaction, error)
	predicates    []predicate.TransferTransaction
}

var _ ent.Mutation = (*TransferTransactionMutation)(nil)

// transfertransactionOption allows management of the mutation configuration using functional options.
type transfertransactionOption func(*TransferTransactionMutation)

// newTransferTransactionMutation creates new mutation for the TransferTransaction entity.
func newTransferTransactionMutation(c config, op Op, opts ...transfertransactionOption) *TransferTransactionMutation {
	m := &TransferTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferTransactionID sets the ID field of the mutation.
func withTransferTransactionID(id int) transfertransactionOption {
	return func(m *TransferTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferTransaction
		)
		m.oldValue = func(ctx context.Context) (*TransferTransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferTransaction sets the old TransferTransaction of the mutation.
func withTransferTransaction(node *TransferTransaction) transfertransactionOption {
	return func(m *TransferTransactionMutation) {
		m.oldValue = func(context.Context) (*TransferTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferTransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TransferTransactionMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TransferTransactionMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TransferTransaction entity.
// If the TransferTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferTransactionMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TransferTransactionMutation) ResetUUID() {
	m.uuid = nil
}

// SetAmount sets the "amount" field.
func (m *TransferTransactionMutation) SetAmount(f float32) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransferTransactionMutation) Amount() (r float32, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransferTransaction entity.
// If the TransferTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferTransactionMutation) OldAmount(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransferTransactionMutation) AddAmount(f float32) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransferTransactionMutation) AddedAmount() (r float32, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransferTransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *TransferTransactionMutation) SetStatus(t transfertransaction.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferTransactionMutation) Status() (r transfertransaction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TransferTransaction entity.
// If the TransferTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferTransactionMutation) OldStatus(ctx context.Context) (v transfertransaction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferTransactionMutation) ResetStatus() {
	m.status = nil
}

// SetTxnType sets the "txn_type" field.
func (m *TransferTransactionMutation) SetTxnType(tt transfertransaction.TxnType) {
	m.txn_type = &tt
}

// TxnType returns the value of the "txn_type" field in the mutation.
func (m *TransferTransactionMutation) TxnType() (r transfertransaction.TxnType, exists bool) {
	v := m.txn_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTxnType returns the old "txn_type" field's value of the TransferTransaction entity.
// If the TransferTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferTransactionMutation) OldTxnType(ctx context.Context) (v transfertransaction.TxnType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxnType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxnType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxnType: %w", err)
	}
	return oldValue.TxnType, nil
}

// ResetTxnType resets all changes to the "txn_type" field.
func (m *TransferTransactionMutation) ResetTxnType() {
	m.txn_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransferTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransferTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransferTransaction entity.
// If the TransferTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransferTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransferTransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransferTransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransferTransaction entity.
// If the TransferTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferTransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransferTransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TransferTransactionMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TransferTransactionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TransferTransactionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TransferTransactionMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TransferTransactionMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TransferTransactionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *TransferTransactionMutation) SetGameID(id int) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *TransferTransactionMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *TransferTransactionMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *TransferTransactionMutation) GameID() (id int, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *TransferTransactionMutation) GameIDs() (ids []int) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *TransferTransactionMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// Where appends a list predicates to the TransferTransactionMutation builder.
func (m *TransferTransactionMutation) Where(ps ...predicate.TransferTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransferTransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransferTransaction).
func (m *TransferTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferTransactionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, transfertransaction.FieldUUID)
	}
	if m.amount != nil {
		fields = append(fields, transfertransaction.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, transfertransaction.FieldStatus)
	}
	if m.txn_type != nil {
		fields = append(fields, transfertransaction.FieldTxnType)
	}
	if m.created_at != nil {
		fields = append(fields, transfertransaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transfertransaction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfertransaction.FieldUUID:
		return m.UUID()
	case transfertransaction.FieldAmount:
		return m.Amount()
	case transfertransaction.FieldStatus:
		return m.Status()
	case transfertransaction.FieldTxnType:
		return m.TxnType()
	case transfertransaction.FieldCreatedAt:
		return m.CreatedAt()
	case transfertransaction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfertransaction.FieldUUID:
		return m.OldUUID(ctx)
	case transfertransaction.FieldAmount:
		return m.OldAmount(ctx)
	case transfertransaction.FieldStatus:
		return m.OldStatus(ctx)
	case transfertransaction.FieldTxnType:
		return m.OldTxnType(ctx)
	case transfertransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transfertransaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TransferTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfertransaction.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case transfertransaction.FieldAmount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transfertransaction.FieldStatus:
		v, ok := value.(transfertransaction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transfertransaction.FieldTxnType:
		v, ok := value.(transfertransaction.TxnType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxnType(v)
		return nil
	case transfertransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transfertransaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TransferTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transfertransaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfertransaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfertransaction.FieldAmount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TransferTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferTransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferTransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransferTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferTransactionMutation) ResetField(name string) error {
	switch name {
	case transfertransaction.FieldUUID:
		m.ResetUUID()
		return nil
	case transfertransaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transfertransaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transfertransaction.FieldTxnType:
		m.ResetTxnType()
		return nil
	case transfertransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transfertransaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TransferTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, transfertransaction.EdgeOwner)
	}
	if m.game != nil {
		edges = append(edges, transfertransaction.EdgeGame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfertransaction.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case transfertransaction.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferTransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, transfertransaction.EdgeOwner)
	}
	if m.clearedgame {
		edges = append(edges, transfertransaction.EdgeGame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transfertransaction.EdgeOwner:
		return m.clearedowner
	case transfertransaction.EdgeGame:
		return m.clearedgame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferTransactionMutation) ClearEdge(name string) error {
	switch name {
	case transfertransaction.EdgeOwner:
		m.ClearOwner()
		return nil
	case transfertransaction.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown TransferTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferTransactionMutation) ResetEdge(name string) error {
	switch name {
	case transfertransaction.EdgeOwner:
		m.ResetOwner()
		return nil
	case transfertransaction.EdgeGame:
		m.ResetGame()
		return nil
	}
	return fmt.Errorf("unknown TransferTransaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	uuid                *uuid.UUID
	tel                 *string
	picture             *string
	username            *string
	password            *string
	status              *user.Status
	bonus               *user.Bonus
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	games               map[int]struct{}
	removedgames        map[int]struct{}
	clearedgames        bool
	transfers           map[int]struct{}
	removedtransfers    map[int]struct{}
	clearedtransfers    bool
	banks               map[int]struct{}
	removedbanks        map[int]struct{}
	clearedbanks        bool
	access_token        map[int]struct{}
	removedaccess_token map[int]struct{}
	clearedaccess_token bool
	line                map[int]struct{}
	removedline         map[int]struct{}
	clearedline         bool
	wallet              map[int]struct{}
	removedwallet       map[int]struct{}
	clearedwallet       bool
	channel             *int
	clearedchannel      bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetTel sets the "tel" field.
func (m *UserMutation) SetTel(s string) {
	m.tel = &s
}

// Tel returns the value of the "tel" field in the mutation.
func (m *UserMutation) Tel() (r string, exists bool) {
	v := m.tel
	if v == nil {
		return
	}
	return *v, true
}

// OldTel returns the old "tel" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTel: %w", err)
	}
	return oldValue.Tel, nil
}

// ResetTel resets all changes to the "tel" field.
func (m *UserMutation) ResetTel() {
	m.tel = nil
}

// SetPicture sets the "picture" field.
func (m *UserMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *UserMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *UserMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[user.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *UserMutation) PictureCleared() bool {
	_, ok := m.clearedFields[user.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, user.FieldPicture)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetBonus sets the "bonus" field.
func (m *UserMutation) SetBonus(u user.Bonus) {
	m.bonus = &u
}

// Bonus returns the value of the "bonus" field in the mutation.
func (m *UserMutation) Bonus() (r user.Bonus, exists bool) {
	v := m.bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldBonus returns the old "bonus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBonus(ctx context.Context) (v user.Bonus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBonus: %w", err)
	}
	return oldValue.Bonus, nil
}

// ResetBonus resets all changes to the "bonus" field.
func (m *UserMutation) ResetBonus() {
	m.bonus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGameIDs adds the "games" edge to the GameAccount entity by ids.
func (m *UserMutation) AddGameIDs(ids ...int) {
	if m.games == nil {
		m.games = make(map[int]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the GameAccount entity.
func (m *UserMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the GameAccount entity was cleared.
func (m *UserMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the GameAccount entity by IDs.
func (m *UserMutation) RemoveGameIDs(ids ...int) {
	if m.removedgames == nil {
		m.removedgames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the GameAccount entity.
func (m *UserMutation) RemovedGamesIDs() (ids []int) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *UserMutation) GamesIDs() (ids []int) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *UserMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// AddTransferIDs adds the "transfers" edge to the TransferTransaction entity by ids.
func (m *UserMutation) AddTransferIDs(ids ...int) {
	if m.transfers == nil {
		m.transfers = make(map[int]struct{})
	}
	for i := range ids {
		m.transfers[ids[i]] = struct{}{}
	}
}

// ClearTransfers clears the "transfers" edge to the TransferTransaction entity.
func (m *UserMutation) ClearTransfers() {
	m.clearedtransfers = true
}

// TransfersCleared reports if the "transfers" edge to the TransferTransaction entity was cleared.
func (m *UserMutation) TransfersCleared() bool {
	return m.clearedtransfers
}

// RemoveTransferIDs removes the "transfers" edge to the TransferTransaction entity by IDs.
func (m *UserMutation) RemoveTransferIDs(ids ...int) {
	if m.removedtransfers == nil {
		m.removedtransfers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transfers, ids[i])
		m.removedtransfers[ids[i]] = struct{}{}
	}
}

// RemovedTransfers returns the removed IDs of the "transfers" edge to the TransferTransaction entity.
func (m *UserMutation) RemovedTransfersIDs() (ids []int) {
	for id := range m.removedtransfers {
		ids = append(ids, id)
	}
	return
}

// TransfersIDs returns the "transfers" edge IDs in the mutation.
func (m *UserMutation) TransfersIDs() (ids []int) {
	for id := range m.transfers {
		ids = append(ids, id)
	}
	return
}

// ResetTransfers resets all changes to the "transfers" edge.
func (m *UserMutation) ResetTransfers() {
	m.transfers = nil
	m.clearedtransfers = false
	m.removedtransfers = nil
}

// AddBankIDs adds the "banks" edge to the BankAccount entity by ids.
func (m *UserMutation) AddBankIDs(ids ...int) {
	if m.banks == nil {
		m.banks = make(map[int]struct{})
	}
	for i := range ids {
		m.banks[ids[i]] = struct{}{}
	}
}

// ClearBanks clears the "banks" edge to the BankAccount entity.
func (m *UserMutation) ClearBanks() {
	m.clearedbanks = true
}

// BanksCleared reports if the "banks" edge to the BankAccount entity was cleared.
func (m *UserMutation) BanksCleared() bool {
	return m.clearedbanks
}

// RemoveBankIDs removes the "banks" edge to the BankAccount entity by IDs.
func (m *UserMutation) RemoveBankIDs(ids ...int) {
	if m.removedbanks == nil {
		m.removedbanks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.banks, ids[i])
		m.removedbanks[ids[i]] = struct{}{}
	}
}

// RemovedBanks returns the removed IDs of the "banks" edge to the BankAccount entity.
func (m *UserMutation) RemovedBanksIDs() (ids []int) {
	for id := range m.removedbanks {
		ids = append(ids, id)
	}
	return
}

// BanksIDs returns the "banks" edge IDs in the mutation.
func (m *UserMutation) BanksIDs() (ids []int) {
	for id := range m.banks {
		ids = append(ids, id)
	}
	return
}

// ResetBanks resets all changes to the "banks" edge.
func (m *UserMutation) ResetBanks() {
	m.banks = nil
	m.clearedbanks = false
	m.removedbanks = nil
}

// AddAccessTokenIDs adds the "access_token" edge to the AccessToken entity by ids.
func (m *UserMutation) AddAccessTokenIDs(ids ...int) {
	if m.access_token == nil {
		m.access_token = make(map[int]struct{})
	}
	for i := range ids {
		m.access_token[ids[i]] = struct{}{}
	}
}

// ClearAccessToken clears the "access_token" edge to the AccessToken entity.
func (m *UserMutation) ClearAccessToken() {
	m.clearedaccess_token = true
}

// AccessTokenCleared reports if the "access_token" edge to the AccessToken entity was cleared.
func (m *UserMutation) AccessTokenCleared() bool {
	return m.clearedaccess_token
}

// RemoveAccessTokenIDs removes the "access_token" edge to the AccessToken entity by IDs.
func (m *UserMutation) RemoveAccessTokenIDs(ids ...int) {
	if m.removedaccess_token == nil {
		m.removedaccess_token = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.access_token, ids[i])
		m.removedaccess_token[ids[i]] = struct{}{}
	}
}

// RemovedAccessToken returns the removed IDs of the "access_token" edge to the AccessToken entity.
func (m *UserMutation) RemovedAccessTokenIDs() (ids []int) {
	for id := range m.removedaccess_token {
		ids = append(ids, id)
	}
	return
}

// AccessTokenIDs returns the "access_token" edge IDs in the mutation.
func (m *UserMutation) AccessTokenIDs() (ids []int) {
	for id := range m.access_token {
		ids = append(ids, id)
	}
	return
}

// ResetAccessToken resets all changes to the "access_token" edge.
func (m *UserMutation) ResetAccessToken() {
	m.access_token = nil
	m.clearedaccess_token = false
	m.removedaccess_token = nil
}

// AddLineIDs adds the "line" edge to the LineAccount entity by ids.
func (m *UserMutation) AddLineIDs(ids ...int) {
	if m.line == nil {
		m.line = make(map[int]struct{})
	}
	for i := range ids {
		m.line[ids[i]] = struct{}{}
	}
}

// ClearLine clears the "line" edge to the LineAccount entity.
func (m *UserMutation) ClearLine() {
	m.clearedline = true
}

// LineCleared reports if the "line" edge to the LineAccount entity was cleared.
func (m *UserMutation) LineCleared() bool {
	return m.clearedline
}

// RemoveLineIDs removes the "line" edge to the LineAccount entity by IDs.
func (m *UserMutation) RemoveLineIDs(ids ...int) {
	if m.removedline == nil {
		m.removedline = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.line, ids[i])
		m.removedline[ids[i]] = struct{}{}
	}
}

// RemovedLine returns the removed IDs of the "line" edge to the LineAccount entity.
func (m *UserMutation) RemovedLineIDs() (ids []int) {
	for id := range m.removedline {
		ids = append(ids, id)
	}
	return
}

// LineIDs returns the "line" edge IDs in the mutation.
func (m *UserMutation) LineIDs() (ids []int) {
	for id := range m.line {
		ids = append(ids, id)
	}
	return
}

// ResetLine resets all changes to the "line" edge.
func (m *UserMutation) ResetLine() {
	m.line = nil
	m.clearedline = false
	m.removedline = nil
}

// AddWalletIDs adds the "wallet" edge to the MasterWalletTransaction entity by ids.
func (m *UserMutation) AddWalletIDs(ids ...int) {
	if m.wallet == nil {
		m.wallet = make(map[int]struct{})
	}
	for i := range ids {
		m.wallet[ids[i]] = struct{}{}
	}
}

// ClearWallet clears the "wallet" edge to the MasterWalletTransaction entity.
func (m *UserMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the MasterWalletTransaction entity was cleared.
func (m *UserMutation) WalletCleared() bool {
	return m.clearedwallet
}

// RemoveWalletIDs removes the "wallet" edge to the MasterWalletTransaction entity by IDs.
func (m *UserMutation) RemoveWalletIDs(ids ...int) {
	if m.removedwallet == nil {
		m.removedwallet = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wallet, ids[i])
		m.removedwallet[ids[i]] = struct{}{}
	}
}

// RemovedWallet returns the removed IDs of the "wallet" edge to the MasterWalletTransaction entity.
func (m *UserMutation) RemovedWalletIDs() (ids []int) {
	for id := range m.removedwallet {
		ids = append(ids, id)
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
func (m *UserMutation) WalletIDs() (ids []int) {
	for id := range m.wallet {
		ids = append(ids, id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *UserMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
	m.removedwallet = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *UserMutation) SetChannelID(id int) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *UserMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *UserMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *UserMutation) ChannelID() (id int, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *UserMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.tel != nil {
		fields = append(fields, user.FieldTel)
	}
	if m.picture != nil {
		fields = append(fields, user.FieldPicture)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.bonus != nil {
		fields = append(fields, user.FieldBonus)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUUID:
		return m.UUID()
	case user.FieldTel:
		return m.Tel()
	case user.FieldPicture:
		return m.Picture()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldStatus:
		return m.Status()
	case user.FieldBonus:
		return m.Bonus()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldTel:
		return m.OldTel(ctx)
	case user.FieldPicture:
		return m.OldPicture(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldBonus:
		return m.OldBonus(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTel(v)
		return nil
	case user.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldBonus:
		v, ok := value.(user.Bonus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBonus(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPicture) {
		fields = append(fields, user.FieldPicture)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPicture:
		m.ClearPicture()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldTel:
		m.ResetTel()
		return nil
	case user.FieldPicture:
		m.ResetPicture()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldBonus:
		m.ResetBonus()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.games != nil {
		edges = append(edges, user.EdgeGames)
	}
	if m.transfers != nil {
		edges = append(edges, user.EdgeTransfers)
	}
	if m.banks != nil {
		edges = append(edges, user.EdgeBanks)
	}
	if m.access_token != nil {
		edges = append(edges, user.EdgeAccessToken)
	}
	if m.line != nil {
		edges = append(edges, user.EdgeLine)
	}
	if m.wallet != nil {
		edges = append(edges, user.EdgeWallet)
	}
	if m.channel != nil {
		edges = append(edges, user.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransfers:
		ids := make([]ent.Value, 0, len(m.transfers))
		for id := range m.transfers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBanks:
		ids := make([]ent.Value, 0, len(m.banks))
		for id := range m.banks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccessToken:
		ids := make([]ent.Value, 0, len(m.access_token))
		for id := range m.access_token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLine:
		ids := make([]ent.Value, 0, len(m.line))
		for id := range m.line {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallet:
		ids := make([]ent.Value, 0, len(m.wallet))
		for id := range m.wallet {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedgames != nil {
		edges = append(edges, user.EdgeGames)
	}
	if m.removedtransfers != nil {
		edges = append(edges, user.EdgeTransfers)
	}
	if m.removedbanks != nil {
		edges = append(edges, user.EdgeBanks)
	}
	if m.removedaccess_token != nil {
		edges = append(edges, user.EdgeAccessToken)
	}
	if m.removedline != nil {
		edges = append(edges, user.EdgeLine)
	}
	if m.removedwallet != nil {
		edges = append(edges, user.EdgeWallet)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransfers:
		ids := make([]ent.Value, 0, len(m.removedtransfers))
		for id := range m.removedtransfers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBanks:
		ids := make([]ent.Value, 0, len(m.removedbanks))
		for id := range m.removedbanks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccessToken:
		ids := make([]ent.Value, 0, len(m.removedaccess_token))
		for id := range m.removedaccess_token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLine:
		ids := make([]ent.Value, 0, len(m.removedline))
		for id := range m.removedline {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallet:
		ids := make([]ent.Value, 0, len(m.removedwallet))
		for id := range m.removedwallet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedgames {
		edges = append(edges, user.EdgeGames)
	}
	if m.clearedtransfers {
		edges = append(edges, user.EdgeTransfers)
	}
	if m.clearedbanks {
		edges = append(edges, user.EdgeBanks)
	}
	if m.clearedaccess_token {
		edges = append(edges, user.EdgeAccessToken)
	}
	if m.clearedline {
		edges = append(edges, user.EdgeLine)
	}
	if m.clearedwallet {
		edges = append(edges, user.EdgeWallet)
	}
	if m.clearedchannel {
		edges = append(edges, user.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGames:
		return m.clearedgames
	case user.EdgeTransfers:
		return m.clearedtransfers
	case user.EdgeBanks:
		return m.clearedbanks
	case user.EdgeAccessToken:
		return m.clearedaccess_token
	case user.EdgeLine:
		return m.clearedline
	case user.EdgeWallet:
		return m.clearedwallet
	case user.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGames:
		m.ResetGames()
		return nil
	case user.EdgeTransfers:
		m.ResetTransfers()
		return nil
	case user.EdgeBanks:
		m.ResetBanks()
		return nil
	case user.EdgeAccessToken:
		m.ResetAccessToken()
		return nil
	case user.EdgeLine:
		m.ResetLine()
		return nil
	case user.EdgeWallet:
		m.ResetWallet()
		return nil
	case user.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
